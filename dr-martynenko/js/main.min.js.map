{"version":3,"sources":["main.js"],"names":["fadeOut","element","duration","opacity","delta","timer","setInterval","style","clearInterval","display","fadeIn","banText","event","parseFloat","key","preventDefault","number","toString","replace","removeSpaces","str","text","el","textContent","div","document","parentElement","width","value","classList","createElement","clientWidth","remove","preventDefaultFunc","e","num","toLocaleString","useGrouping","body","docEl","scrollTop","scrollLeft","documentElement","clientTop","clientLeft","top","left","box","params","url","undefined","isArray","URL","searchParams","forEach","val","push","Array","getCurrentTime","hours","Date","now","getHours","minutes","getMinutes","isObjectEmpty","obj","JSON","stringify","getStyle","elem","window","getComputedStyle","currentStyle","wordBreaking","split","className","title","item","querySelector","words","innerHTML","trim","length","increaseDecreaseNumber","targetElement","startValue","endValue","startTime","performance","change","timestamp","elapsed","progress","Math","min","currentValue","floor","requestAnimationFrame","formatNumber","updateNumber","target","btn","removeBtnClassName","itsEl","its_btn","its_el_is_open","button","toggle","closest","contains","CustomSelect","constructor","method","options","selectElement","this","initCustomSelect","show","select","icon","isMobile","replaceCustomWithDefault","querySelectorAll","defaultSelect","customSelectEvents","customSelect","createCustomSelect","replaceSelectWithCustom","add","selectClasses","from","selectTitle","createCustomSelectTitle","selectContent","createCustomSelectContent","append","selectTitleIcon","selectedOption","find","option","selected","selectTitleText","overlay","selectContentWrap","createCustomSelectOptions","label","index","optionAttributes","attribute","setAttribute","input","span","attributes","map","name","checked","replaceWith","appendChild","titleText","content","labelText","labels","inputValue","addEventListener","labelHeight","maxHeight","clickOutsideSelect","its_overlay","selectName","createDefaultSelect","required","createDefaultOptions","inputAttributes","formNameValid","isRequired","l","elCheck","formPhoneValid","formEmailValid","emailValid","match","formIndexValid","messages","parent","inputs","i","maxLength","checkboxValid","msgHidden","selector","multiple","headings","bindEvents","closeOthers","heading","close","open","currentElement","autoSubmit","form","validationFunctions","formReset","email","agreement","phone","textarea","formTextareaValid","address","formPromocodeValid","selects","formCustomSelectValid","promo","excludeFields","checkboxFields","fields","formFields","init","reset","submit","formAutoSubmit","fieldAddHandle","onclick","submitHandler","formSubmit","addFieldIfExist","validateFields","validationResult","handler","field","getFieldsProps","props","validate","myProps","listener","Function","isMessage","messageLength","includes","isSelect","result","isCustom","fieldCheckValidation","fieldName","validationErrors","validation","fieldsValues","getFieldsValues","formData","FormData","FormSender","requiredFields","checkOnChange","keys","checkValues","values","data","astrooma","dr_martynenko","ajaxurl","parse","get","getFormProps","action","Object","assign","sendFormPost","id","defaultForm","formClass","showDescription","requestType","baseRequest","onError","beforeSend","success","response","dealIdInput","type","dealId","HandlerForm","xhr","exception","ajaxErrors","onComplete","code","getElementById","modal","thxModal","requestData","requestOptions","ok","Error","status","json","then","catch","error","finally","entries","promocodeText","File","console","log","header","laptop","responseText","tablet","mobile","footer","main","stickyMenu","calculateDynamicValue","headerFixed","footerHeight","offsetHeight","headerMain","headerHeight","headerCatalogOpenBtn","headerCatalog","toggleSubMenu","listItem","catalogLists","getParentListAndCategory","removeHoverClass","listItems","dataset","category","submenuClass","parentList","catalogItems","list","clickOutside","links","smoothScroll","isOpenButton","getAttribute","isOverlay","targetId","offsetTop","scrollTo","modalId","link","isCloseButton","hamburger","closeHamburger","hamburgerWrap","setTimeout","hamburgerClose","isHamburgerWrap","isHamburger","inputsPhone","isOpen","inputsEmail","emailMask","accordions","geographyTabs","Accordion","accordion","IMask","mask","feedbackFormOnPage","tab","currentTab","dataTab","geographyTabsContent","contentTab","dataContentTab","sliderWrapElement","sliderClassName","navButtons","policyLinks","handleClick","slides","slider","href","prevButton","parentSection","customSelects","sliderInitCheck","sliderWrap","slideClassName","showBullets","nextButton","swiper","Swiper","speed","pagination","clickable","bullets","slide","essentialSliderInit","max","height","spaceBetween","mainSlider","momentum","momentumRatio","grabCursor","essentialSlider","slidesPerView","loop","prevEl","mainHeroSlider","productsSliderSection","productsSliderInit","reviewsSlider","groupSize","section","navigation","nextEl","group","setEqualHeight","reviewsSliders","pages","webinarsHeroSlider","groupedSlides","commonOptions","on","breakpoints","btnMore","reviewFile","reviewFileParent","image","review","files","customFile","readAsDataURL","outputContainer","plug","reviewsButtons","img","file","aImg","reader","FileReader","onload","src","outputHtml","scrollHorizontally","wrappers","childWidth","child","offsetWidth","firstElementChild","wrapper","offset"],"mappings":"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","file":"main.min.js","sourcesContent":["/**\r\n * Анимирует постепенное исчезновение HTML-элемента с использованием эффекта уменьшения прозрачности (fade out).\r\n * По завершении анимации элемент будет скрыт (display: none).\r\n *\r\n * @param {HTMLElement} element - HTML-элемент, который необходимо анимировать.\r\n * @param {number} duration - Продолжительность анимации в миллисекундах.\r\n */\r\nfunction fadeOut(element, duration) {\r\n    // Устанавливаем начальное значение прозрачности элемента (по умолчанию 1 - полностью непрозрачный)\r\n    var opacity = 1;\r\n\r\n    // Вычисляем шаг изменения прозрачности.\r\n    // Чем меньше значение delta, тем медленнее будет происходить изменение прозрачности.\r\n    // duration / 10 - это количество шагов анимации, чтобы каждые 10 мс выполнять изменение прозрачности.\r\n    var delta = 1 / (duration / 10);\r\n\r\n    // Создаем таймер, который будет запускать функцию каждые 10 миллисекунд для изменения значения прозрачности\r\n    var timer = setInterval(function() {\r\n        // Уменьшаем текущую прозрачность на вычисленный шаг\r\n        opacity -= delta;\r\n\r\n        // Применяем новое значение прозрачности к стилю элемента\r\n        element.style.opacity = opacity;\r\n\r\n        // Если прозрачность становится равной или меньше 0 (полностью прозрачный элемент), останавливаем анимацию\r\n        if (opacity <= 0) {\r\n            // Очищаем таймер, чтобы остановить выполнение анимации\r\n            clearInterval(timer);\r\n\r\n            // Скрываем элемент, установив для него стиль display: 'none', чтобы он не занимал место на странице\r\n            element.style.display = 'none';\r\n        }\r\n    }, 10); // Шаг анимации - каждые 10 миллисекунд вызывается изменение прозрачности\r\n}\r\n\r\n/**\r\n * Анимирует постепенное появление HTML-элемента с использованием эффекта увеличения прозрачности (fade in).\r\n * Элемент становится видимым (display: block) и постепенно достигает полной непрозрачности.\r\n *\r\n * @param {HTMLElement} element - HTML-элемент, который необходимо анимировать.\r\n * @param {number} duration - Продолжительность анимации в миллисекундах.\r\n */\r\nfunction fadeIn(element, duration) {\r\n    // Устанавливаем начальное значение прозрачности элемента на 0 (полностью прозрачный)\r\n    var opacity = 0;\r\n\r\n    // Вычисляем шаг изменения прозрачности. Чем меньше значение delta, тем медленнее будет происходить изменение.\r\n    // duration / 10 - это количество шагов анимации (каждые 10 мс).\r\n    var delta = 1 / (duration / 10);\r\n\r\n    // Отображаем элемент (если он был скрыт) перед запуском анимации\r\n    element.style.display = 'block';\r\n\r\n    // Устанавливаем начальное значение прозрачности, чтобы элемент начинал появляться с прозрачности 0\r\n    element.style.opacity = opacity;\r\n\r\n    // Запускаем таймер для постепенного увеличения прозрачности элемента\r\n    var timer = setInterval(function() {\r\n        // Увеличиваем текущее значение прозрачности\r\n        opacity += delta;\r\n\r\n        // Применяем новое значение прозрачности к стилю элемента\r\n        element.style.opacity = opacity;\r\n\r\n        // Если прозрачность достигает 1 (полностью непрозрачный элемент), завершаем анимацию\r\n        if (opacity >= 1) {\r\n            // Останавливаем таймер, чтобы прекратить дальнейшее изменение прозрачности\r\n            clearInterval(timer);\r\n\r\n            // Для точности устанавливаем прозрачность в 1, чтобы предотвратить случайные погрешности\r\n            element.style.opacity = 1;\r\n        }\r\n    }, 10); // Шаг анимации - каждые 10 миллисекунд\r\n}\r\n\r\n/**\r\n * Функция для блокировки ввода текста, кроме числовых значений, на элементе формы.\r\n * @param {Event} event - Событие ввода.\r\n */\r\nfunction banText(event) {\r\n    var banText = parseFloat(event.key);\r\n\r\n    if (isNaN(banText)) {\r\n        event.preventDefault();\r\n    }\r\n}\r\n\r\n/**\r\n * Функция для приведения числа в денежный формат\r\n * @param { Number } number\r\n * @returns {string}\r\n */\r\nfunction formatNumber(number) {\r\n    return number.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \" \");\r\n}\r\n\r\nfunction removeSpaces(str) {\r\n    return str.replace(/\\s+/g, '');\r\n}\r\n\r\n/**\r\n * Функция для автоматического изменения ширины поля ввода в зависимости от его содержимого.\r\n * @param {HTMLInputElement} el - Элемент поля ввода.\r\n */\r\nfunction resizeInput(el) {\r\n    let parent = el.parentElement;\r\n    let text = el.value;\r\n    let div = document.createElement('div');\r\n    let width;\r\n\r\n    div.classList.add('size-div');\r\n    div.textContent = text;\r\n    parent.append(div);\r\n\r\n    width = div.clientWidth;\r\n    el.style.width = width + 'px';\r\n    div.remove();\r\n}\r\n\r\n/**\r\n * Функция для предотвращения действия по умолчанию в событии.\r\n * @param {Event} e - Событие.\r\n */\r\nfunction preventDefaultFunc(e) {\r\n    e.preventDefault();\r\n}\r\n\r\n/**\r\n * Функция для форматирования числового значения как цены с использованием разделителя тысяч.\r\n * @param {number} num - Форматируемое число.\r\n * @returns {string} - Отформатированная строка цены.\r\n */\r\nfunction formatPrice(num) {\r\n    num = parseFloat(num);\r\n    return num.toLocaleString('en-US', {useGrouping: true}).replace(/,/g, ' ');\r\n}\r\n\r\n/**\r\n * Функция для получения координат элемента на странице.\r\n * @param {HTMLElement} elem - Элемент, координаты которого необходимо получить.\r\n * @returns {Object} - Объект с координатами элемента (top, left).\r\n */\r\nfunction getCoords(elem) {\r\n    var box = elem.getBoundingClientRect();\r\n    var body = document.body;\r\n    var docEl = document.documentElement;\r\n    var scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;\r\n    var scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;\r\n    var clientTop = docEl.clientTop || body.clientTop || 0;\r\n    var clientLeft = docEl.clientLeft || body.clientLeft || 0;\r\n    var top = box.top + scrollTop - clientTop;\r\n    var left = box.left + scrollLeft - clientLeft;\r\n\r\n    return {\r\n        top: top,\r\n        left: left\r\n    };\r\n}\r\n\r\n/**\r\n * Функция для извлечения параметров из URL.\r\n * @param {string} url - URL-адрес, из которого извлекаются параметры (по умолчанию текущий URL).\r\n * @returns {Object} - Объект с параметрами из URL.\r\n */\r\nfunction getParams(url = window.location) {\r\n    let params = {};\r\n\r\n    new URL(url).searchParams.forEach(function (val, key) {\r\n        if (params[key] !== undefined) {\r\n            if (!Array.isArray(params[key])) {\r\n                params[key] = [params[key]];\r\n            }\r\n            params[key].push(val);\r\n        } else {\r\n            params[key] = val;\r\n        }\r\n    });\r\n\r\n    return params;\r\n}\r\n\r\n/**\r\n * Функция для получения текущего времени в формате \"часы:минуты\".\r\n * @returns {string} - Текущее время в формате \"часы:минуты\".\r\n */\r\nfunction getCurrentTime() {\r\n    const now = new Date();\r\n    let hours = now.getHours();\r\n    let minutes = now.getMinutes();\r\n\r\n    hours = hours < 10 ? '0' + hours : hours;\r\n    minutes = minutes < 10 ? '0' + minutes : minutes;\r\n\r\n    return hours + ':' + minutes;\r\n}\r\n\r\n\r\n/**\r\n * Функция для проверки, является ли объект пустым.\r\n * @param {Object} obj - Проверяемый объект.\r\n * @returns {boolean} - Возвращает true, если объект пустой, иначе возвращает false.\r\n */\r\nfunction isObjectEmpty(obj) {\r\n    return JSON.stringify(obj) === '{}';\r\n}\r\n\r\n/**\r\n * Функция для получения стилей элемента.\r\n *\r\n * @param {HTMLElement} elem - HTML-элемент, для которого нужно получить стили.\r\n * @return {CSSStyleDeclaration | Object} - Объект, содержащий стили элемента.\r\n */\r\nfunction getStyle(elem) {\r\n    // Проверяем, поддерживается ли метод window.getComputedStyle\r\n    if (window.getComputedStyle) {\r\n        // Если да, используем его для получения стилей элемента\r\n        // Первый параметр - элемент, второй - псевдоэлемент (null для обычного элемента)\r\n        return getComputedStyle(elem, null);\r\n    } else {\r\n        // Если метод window.getComputedStyle не поддерживается (например, в старых версиях IE),\r\n        // используем свойство currentStyle элемента, которое возвращает объект стилей\r\n        return elem.currentStyle;\r\n    }\r\n}\r\n\r\n/**\r\n * Разделяет текст элемента на два слова и вставляет между ними разрыв строки.\r\n *\r\n * @param {HTMLElement} item - Родительский элемент, внутри которого ищем нужный текст.\r\n * @param {string} className - Класс элемента, содержащего текст, который нужно разделить на две строки.\r\n */\r\nconst wordBreaking = (item, className) => {\r\n    // Находим элемент с переданным классом внутри родительского элемента\r\n    const title = item.querySelector(className);\r\n\r\n    // Получаем текст внутри элемента и удаляем пробелы в начале и конце строки\r\n    const text = title.textContent.trim();\r\n\r\n    // Разделяем текст на массив слов по пробелам\r\n    const words = text.split(' ');\r\n\r\n    // Если в тексте ровно два слова, выполняем замену текста с разрывом строки\r\n    if (words.length === 2) {\r\n        // Вставляем разрыв строки между первым и вторым словом\r\n        title.innerHTML = `${words[0]}<br>${words[1]}`;\r\n    }\r\n};\r\n\r\n/**\r\n * Увеличивает/уменьшает число в указанном элементе до указанного конечного значения за указанное время.\r\n * @param {HTMLElement} targetElement - Элемент, в котором будет отображаться число.\r\n * @param {number} startValue - Начальное значение числа.\r\n * @param {number} endValue - Конечное значение числа.\r\n * @param {number} duration - Длительность анимации в миллисекундах.\r\n * @param {string} text - Дополнительный текст.\r\n */\r\nfunction increaseDecreaseNumber(targetElement, startValue, endValue, duration, text) {\r\n    // Получаем время начала анимации\r\n    const startTime = performance.now();\r\n    // Вычисляем разницу между начальным и конечным значениями числа\r\n    const change = endValue - startValue;\r\n\r\n    // Функция обновления числа для каждого кадра анимации\r\n    function updateNumber(timestamp) {\r\n        // Вычисляем прошедшее время с начала анимации\r\n        const elapsed = timestamp - startTime;\r\n        // Вычисляем прогресс анимации от 0 до 1\r\n        const progress = Math.min(elapsed / duration, 1);\r\n        // Вычисляем текущее значение числа с учетом прогресса\r\n        const currentValue = Math.floor(startValue + change * progress);\r\n        // Обновляем текстовое содержимое элемента\r\n        if (!!text) {\r\n            targetElement.textContent = formatNumber(currentValue) + ' ' + text;\r\n        } else {\r\n            targetElement.textContent = formatNumber(currentValue);\r\n        }\r\n\r\n        // Если анимация не завершена, вызываем функцию обновления снова через requestAnimationFrame\r\n        if (progress < 1) {\r\n            requestAnimationFrame(updateNumber);\r\n        } else {\r\n            // Если прогресс достиг 1, значит анимация завершена, устанавливаем конечное значение числа\r\n            if (!!text) {\r\n                targetElement.textContent = formatNumber(endValue) + ' ' + text;\r\n            } else {\r\n                targetElement.textContent = formatNumber(endValue);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Начинаем анимацию, вызывая функцию обновления первый раз через requestAnimationFrame\r\n    requestAnimationFrame(updateNumber);\r\n}\r\n\r\n\r\n// клик вне элемента\r\n\r\nfunction clickOutside({el, btn, className, removeBtnClassName = false}) {\r\n    var element = document.querySelector(el),\r\n        button = document.querySelector(btn);\r\n\r\n    document.addEventListener('click', e => {\r\n        let target = e.target;\r\n        let itsEl = target == element || element.contains(target);\r\n        let its_btn = target === button || target.closest(btn) === button;\r\n        let its_el_is_open = element.classList.contains(className);\r\n\r\n        if (!itsEl && !its_btn && its_el_is_open) {\r\n            element.classList.toggle(className);\r\n            removeBtnClassName && button.classList.toggle(className);\r\n        }\r\n    });\r\n}\r\n;\r\n\r\n// валидация формы\r\n\r\n// кастомный select\r\n\r\nclass CustomSelect {\r\n    /**\r\n     * Конструктор класса CustomSelect.\r\n     * @param {string} method - Название метода инициализации. Может быть 'init', 'reinit' или 'destroy'.\r\n     * @param {Object} options - Объект с настройками.\r\n     * @param {HTMLElement} options.selectElement - HTML-элемент, представляющий оригинальный выпадающий список.\r\n     * @param {number} [options.show=8] - Количество элементов, которые нужно показать в выпадающем списке без прокрутки (по умолчанию 8).\r\n     * @param {string} [options.icon=null] - Иконка для кастомного выпадающего списка. По умолчанию используется null.\r\n     */\r\n    constructor(method, options) {\r\n        // Сохраняем переданный элемент выпадающего списка и количество элементов, которые нужно показать\r\n        this.select = options.selectElement;\r\n        this.show = options.show || 6;\r\n        this.icon = options.icon || null;\r\n        this.isMobile = document.documentElement.clientWidth < 575.98;\r\n\r\n        // Если метод инициализации равен 'init', инициализируем пользовательский выпадающий список\r\n        if (method === 'init') {\r\n            this.initCustomSelect(this.select);\r\n        } else {\r\n            // Если метод не 'init', проверяем, является ли элемент select\r\n            if (this.select.nodeName === 'DIV') {\r\n                // Если элемент DIV, находим все радио-кнопки внутри него\r\n                this.options = this.select.querySelectorAll('input[type=\"radio\"]');\r\n                // Создаем стандартный выпадающий список\r\n                this.defaultSelect = this.createDefaultSelect();\r\n                // Заменяем пользовательский выпадающий список на стандартный\r\n                this.replaceCustomWithDefault();\r\n\r\n                // Если метод переинициализации равен 'reinit', повторно инициализируем пользовательский выпадающий список\r\n                if (method === 'reinit') {\r\n                    this.initCustomSelect(this.defaultSelect);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Инициализирует кастомный выпадающий список на основе оригинального элемента select.\r\n     * @param {HTMLElement} select - HTML-элемент, представляющий оригинальный выпадающий список.\r\n     */\r\n    initCustomSelect(select) {\r\n        // Получаем список опций выпадающего списка\r\n        this.options = select.querySelectorAll('option');\r\n        this.select = select;\r\n        // Создаем кастомный выпадающий список и настраиваем его обработчики событий\r\n        const customSelect = this.createCustomSelect(select);\r\n        // Заменяем оригинальный выпадающий список кастомным\r\n        this.replaceSelectWithCustom(customSelect);\r\n        // Назначаем обработчики событий для кастомного выпадающего списка\r\n        this.customSelectEvents(customSelect);\r\n        customSelect.classList.add('initialized');\r\n    }\r\n\r\n    /**\r\n     * Создает кастомный выпадающий список на основе переданного оригинального элемента select.\r\n     * @param {HTMLElement} select - HTML-элемент, представляющий оригинальный выпадающий список.\r\n     * @returns {HTMLElement} - HTML-элемент, представляющий кастомный выпадающий список.\r\n     */\r\n    createCustomSelect(select) {\r\n        // Создаем новый div и копируем классы из оригинального селекта\r\n        let selectClasses = Array.from(select.classList);\r\n        let customSelect = document.createElement('div');\r\n        selectClasses.forEach(className => customSelect.classList.add(className));\r\n        customSelect.classList.add('custom-select')\r\n        if (select.required) {\r\n            customSelect.classList.add('required')\r\n        }\r\n\r\n        // Создаем заголовок и содержимое списка выбора\r\n        let selectTitle = this.createCustomSelectTitle(customSelect);\r\n        let selectContent = this.createCustomSelectContent(customSelect);\r\n\r\n        // Добавляем заголовок и содержимое к новому выпадающему списку\r\n        customSelect.append(selectTitle);\r\n        customSelect.append(selectContent);\r\n\r\n        return customSelect;\r\n    }\r\n\r\n    /**\r\n     * Создает заголовок для кастомного выпадающего списка.\r\n     * @returns {HTMLElement} - HTML-элемент, представляющий заголовок кастомного выпадающего списка.\r\n     */\r\n    createCustomSelectTitle(customSelect) {\r\n        // Получаем все опции выбора и преобразуем их в массив\r\n        let optionsArray = Array.from(this.options);\r\n\r\n        // Находим выбранную опцию\r\n        let selectedOption = optionsArray.find(option => option.selected);\r\n        // Создаем элементы для заголовка кастомного селекта\r\n        let selectTitle = document.createElement('div'); // Создаем div для обертки заголовка\r\n        let selectTitleText = document.createElement('div'); // Создаем div для текста заголовка\r\n        let selectTitleIcon = document.createElement('div'); // Создаем div для иконки заголовка\r\n\r\n        // Если иконка не задана, используем иконку стрелки вниз по умолчанию\r\n        if (this.icon === null) {\r\n            this.icon = '<svg width=\"12\" height=\"9\" viewBox=\"0 0 10 7\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.64637 6.0565L0.353478 1.7636C0.158216 1.56834 0.158216 1.25176 0.353478 1.0565L1.05686 0.353112C1.25193 0.158042 1.56814 0.157822 1.76348 0.352619L4.99992 3.58005L8.23637 0.352619C8.43171 0.157822 8.74792 0.158042 8.94299 0.353112L9.64637 1.0565C9.84163 1.25176 9.84163 1.56834 9.64637 1.7636L5.35348 6.0565C5.15822 6.25176 4.84163 6.25176 4.64637 6.0565Z\" fill=\"currentColor\"/></svg>';\r\n        }\r\n\r\n        // Добавляем классы для стилизации\r\n        selectTitle.classList.add('select-title'); // Добавляем класс для обертки заголовка\r\n        selectTitleText.classList.add('select-title__text'); // Добавляем класс для текста заголовка\r\n        selectTitleIcon.classList.add('select-title__icon'); // Добавляем класс для иконки заголовка\r\n        // Устанавливаем текст заголовка и иконку\r\n        selectTitleText.textContent = selectedOption.textContent; // Устанавливаем текст заголовка из выбранной опции\r\n        selectTitleIcon.innerHTML = this.icon; // Устанавливаем иконку заголовка\r\n\r\n        // Добавляем текст и иконку к заголовку\r\n        selectTitle.append(selectTitleText); // Добавляем текст заголовка в обертку\r\n        selectTitle.append(selectTitleIcon); // Добавляем иконку заголовка в обертку\r\n\r\n        if (selectedOption.value !== '') {\r\n            customSelect.classList.add('active');\r\n        }\r\n\r\n        return selectTitle; // Возвращаем сформированный заголовок\r\n    }\r\n\r\n\r\n    /**\r\n     * Создает контент для кастомного выпадающего списка.\r\n     * @returns {HTMLElement} - HTML-элемент, представляющий контент кастомного выпадающего списка.\r\n     */\r\n    createCustomSelectContent() {\r\n        // Создаем контейнер для содержимого выпадающего списка\r\n        let selectContent = document.createElement('div');\r\n        selectContent.classList.add('select-content');\r\n\r\n        // Создаем обертку для опций и добавляем их\r\n        let selectContentWrap = this.createCustomSelectOptions();\r\n        selectContent.append(selectContentWrap);\r\n\r\n        if (this.isMobile) {\r\n            let overlay = document.createElement('div');\r\n            overlay.classList.add('select-content_overlay');\r\n            selectContent.append(overlay);\r\n        }\r\n\r\n        return selectContent;\r\n    }\r\n\r\n    /**\r\n     * Создает обертку для опций кастомного выпадающего списка.\r\n     * @returns {HTMLElement} - HTML-элемент, представляющий обертку для опций кастомного выпадающего списка.\r\n     */\r\n    createCustomSelectOptions() {\r\n        // Создаем обертку для опций\r\n        let selectContentWrap = document.createElement('div');\r\n        selectContentWrap.classList.add('select-content_wrap');\r\n\r\n        // Перебираем опции оригинального селекта и создаем для каждой опции метку\r\n        this.options.forEach((option, index) => {\r\n            // console.log(option)\r\n            // Создаем элементы метки и радио-кнопки\r\n            const label = document.createElement('label');\r\n            const input = document.createElement('input');\r\n            const span = document.createElement('span');\r\n\r\n            // Добавляем созданным элементам классы\r\n            label.classList.add('select-content__wrapper');\r\n            span.classList.add('select-content__radio');\r\n\r\n            // Добавляем радио-кнопке атрибуты и устанавливаем ей тип и имя\r\n            const optionAttributes = [...option.attributes];\r\n            // Перебираем массив атрибутов `<option>`\r\n            optionAttributes.map(attribute => {\r\n                if (attribute.name === 'selected') {\r\n                    input.setAttribute('checked', 'checked');\r\n                    input.checked = true;\r\n                } else {\r\n                    input.setAttribute(attribute.name, attribute.value);\r\n                }\r\n\r\n                if (attribute.name === 'disabled') {\r\n                    label.classList.add('disabled');\r\n                }\r\n            });\r\n            input.setAttribute('type', 'radio');\r\n            input.setAttribute('name', this.select.name);\r\n\r\n            // Устанавливаем текст метки\r\n            // span.textContent = option.textContent.trim();\r\n            // console.log(option)\r\n            span.innerHTML = option.innerHTML;\r\n\r\n            // Добавляем радио-кнопку и метку в обертку опций\r\n            label.append(input);\r\n            label.append(span);\r\n            selectContentWrap.appendChild(label);\r\n        });\r\n\r\n        return selectContentWrap;\r\n    }\r\n\r\n    /**\r\n     * Заменяет оригинальный выпадающий список кастомным.\r\n     * @param {HTMLElement} select - HTML-элемент, представляющий кастомный выпадающий список.\r\n     */\r\n    replaceSelectWithCustom(select) {\r\n        // Заменяем оригинальный выпадающий список кастомным\r\n        this.select.replaceWith(select);\r\n    }\r\n\r\n    /**\r\n     * Назначает обработчики событий для кастомного выпадающего списка.\r\n     * @param {HTMLElement} select - HTML-элемент, представляющий кастомный выпадающий список.\r\n     */\r\n    customSelectEvents(select) {\r\n        // Находим заголовок и содержимое списка выбора в кастомном выпадающем списке\r\n        let title = select.querySelector('.select-title');\r\n        let titleText = select.querySelector('.select-title__text');\r\n        let content = select.querySelector('.select-content');\r\n\r\n        // Находим все метки в списке выбора\r\n        let labels = content.querySelectorAll('.select-content__wrapper');\r\n        let labelCount = labels.length;\r\n        let labelHeight = 0;\r\n\r\n        // Вычисляем высоту блока меток, которые будут показаны\r\n        labels.forEach((label, index) => {\r\n            if (index <= this.show) {\r\n                labelHeight += label.offsetHeight;\r\n            }\r\n\r\n            // Добавляем обработчик события клика для каждой метки\r\n            label.addEventListener('click', () => {\r\n                // Получаем текст выбранной метки\r\n                let labelText = label.querySelector('.select-content__radio').textContent;\r\n                let input = label.querySelector('input');\r\n                let inputValue = input.value;\r\n\r\n                // делаем input выбранным\r\n                input.checked = true;\r\n                // Изменяем текст заголовка списка выбора\r\n                titleText.textContent = labelText;\r\n                // Закрываем список выбора\r\n                select.classList.remove('open');\r\n\r\n                if (this.isMobile) {\r\n                    document.body.classList.remove('no-scroll');\r\n                    document.querySelector('main').classList.remove('layer-up');\r\n                }\r\n                // добавляем класс, после первого выбора\r\n                if (!select.classList.contains('active')) {\r\n                    select.classList.add('active');\r\n                }\r\n\r\n                if (inputValue === '') {\r\n                    select.classList.remove('active')\r\n                } else {\r\n                    title.classList.remove('validate')\r\n                }\r\n            });\r\n        });\r\n\r\n        // Если количество меток меньше или равно количеству меток, которые нужно показать,\r\n        // то добавляем класс no-scroll для предотвращения прокрутки\r\n        if (labelCount <= this.show) {\r\n            content.classList.add('no-scroll');\r\n        }\r\n\r\n        // Устанавливаем максимальную высоту блока меток\r\n        content.style.maxHeight = labelHeight + 32 + 'px';\r\n\r\n        // Добавляем обработчик события клика для заголовка списка выбора\r\n        title.addEventListener('click', () => {\r\n            // Закрываем все открытые списки выбора\r\n            document.querySelectorAll('.select').forEach(item => {\r\n                if (item !== select) {\r\n                    item.classList.remove('open');\r\n                    if (this.isMobile) {\r\n                        document.body.classList.remove('no-scroll');\r\n                        document.querySelector('main').classList.remove('layer-up');\r\n                    }\r\n                }\r\n            });\r\n\r\n            // Открываем или закрываем список выбора\r\n            select.classList.toggle('open');\r\n            if (this.isMobile) {\r\n                document.body.classList.toggle('no-scroll');\r\n                document.querySelector('main').classList.toggle('layer-up');\r\n            }\r\n        });\r\n\r\n        // Добавляем обработчик события клика вне кастомного выпадающего списка\r\n        this.clickOutsideSelect(select, title);\r\n    }\r\n\r\n    /**\r\n     * Обрабатывает событие клика вне кастомного выпадающего списка.\r\n     * @param {HTMLElement} select - HTML-элемент, представляющий кастомный выпадающий список.\r\n     * @param {HTMLElement} title - HTML-элемент, представляющий заголовок списка выбора.\r\n     */\r\n    clickOutsideSelect(select, title) {\r\n        document.addEventListener('click', e => {\r\n            let target = e.target;\r\n            let itsEl = target == select || select.contains(target);\r\n            let its_btn = target == title;\r\n            let its_overlay = target.classList.contains('select-content_overlay')\r\n            let its_el_is_open = select.classList.contains('open');\r\n\r\n            // Закрываем выпадающий список, если произошел клик вне его области\r\n            if (!itsEl && !its_btn && its_el_is_open) {\r\n                select.classList.toggle('open');\r\n                if (this.isMobile) {\r\n                    document.body.classList.toggle('no-scroll');\r\n                }\r\n            }\r\n\r\n            if (its_overlay && its_el_is_open) {\r\n                select.classList.remove('open');\r\n                if (this.isMobile) {\r\n                    document.body.classList.remove('no-scroll');\r\n                    document.querySelector('main').classList.remove('layer-up');\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Заменяет кастомный выпадающий список на оригинальный.\r\n     */\r\n    replaceCustomWithDefault() {\r\n        this.select.replaceWith(this.defaultSelect);\r\n    }\r\n\r\n    /**\r\n     * Создает оригинальный выпадающий список.\r\n     * @returns {HTMLSelectElement} - Созданный оригинальный выпадающий список.\r\n     */\r\n    createDefaultSelect() {\r\n        // Получаем классы из кастомного селекта\r\n        const customSelect = this.select;\r\n        let selectClasses = Array.from(customSelect.classList);\r\n\r\n        // Создаем элемент select\r\n        let defaultSelect = document.createElement('select');\r\n\r\n        // Получаем имя оригинального селекта\r\n        let selectName = this.options[0].name;\r\n\r\n        // Добавляем классы к созданному селекту\r\n        selectClasses.forEach(className => defaultSelect.classList.add(className) );\r\n        defaultSelect.classList.remove('active', 'custom-select', 'required');\r\n        if (customSelect.classList.contains('required')) {\r\n            defaultSelect.required = true;\r\n        }\r\n\r\n        // Устанавливаем имя оригинального селекта\r\n        defaultSelect.name = selectName;\r\n\r\n        // Добавляем остальные опции\r\n        this.options.forEach(input => {\r\n            defaultSelect.append(this.createDefaultOptions(input));\r\n        });\r\n\r\n        return defaultSelect;\r\n    }\r\n\r\n    /**\r\n     * Создает опцию для оригинального выпадающего списка.\r\n     * @param {HTMLInputElement} input - Элемент input из кастомного селекта.\r\n     * @returns {HTMLOptionElement|boolean} - Созданная опция для оригинального выпадающего списка или false, если input не содержит значения.\r\n     */\r\n    createDefaultOptions(input) {\r\n        // Проверяем, что значение input не пустое\r\n        // Получаем атрибуты input\r\n        const inputAttributes = [...input.attributes];\r\n\r\n        // Создаем элемент option\r\n        let option = document.createElement('option');\r\n\r\n        // Получаем текстовое содержимое метки для этой опции\r\n        let textContent = input.parentElement.querySelector('.select-content__radio').textContent.trim();\r\n\r\n        // Устанавливаем атрибуты элемента option на основе атрибутов input\r\n        inputAttributes.forEach(attribute => {\r\n            let name = attribute.name;\r\n\r\n            // Исключаем атрибуты 'type' и 'name'\r\n            if (name !== 'type' && name !== 'name' && name !== 'checked') {\r\n                option.setAttribute(name, attribute.value);\r\n            }\r\n\r\n            if (name === 'checked') {\r\n                option.setAttribute('selected', 'selected')\r\n                option.selected = true;\r\n            }\r\n        });\r\n\r\n        let optionClasses = Array.from(input.classList);\r\n        optionClasses.forEach(className => option.classList.add(className));\r\n\r\n        // Устанавливаем текстовое содержимое опции\r\n        option.textContent = textContent;\r\n\r\n        return option;\r\n    }\r\n}\r\n;\r\n/**\r\n * Проверка валидности значения имени в поле формы.\r\n * @param {HTMLElement} el - Элемент формы, содержащий значение.\r\n * @param {boolean} [isRequired=false] - Флаг, указывающий, является ли электронная почта обязательным полем.\r\n * @returns {Object} - Объект с элементом и флагом результата валидации.\r\n */\r\nfunction formNameValid(el, isRequired = false) {\r\n    // Получаем длину значения в поле\r\n    let l = el.value.length;\r\n    let elCheck = true;\r\n\r\n    if (isRequired) {\r\n        if (l === 0) {\r\n            elCheck = false;\r\n            el.classList.add('validate'); // Добавляем класс для стилизации невалидного поля\r\n            el.parentElement.querySelector('.msg').style.display = 'none'; // Скрываем сообщение об успешной валидации\r\n            el.parentElement.querySelector('.msg-error').style.display = 'block'; // Показываем сообщение об ошибке: поле обязательно для заполнения\r\n        } else if (l !== 0 && l < 2) {\r\n            elCheck = false;\r\n            el.parentElement.querySelector('.msg').style.display = 'none'; // Скрываем сообщение об успешной валидации\r\n            el.parentElement.querySelector('.msg-empty').style.display = 'block'; // Показываем сообщение об ошибке: значение слишком короткое\r\n            el.classList.add('validate'); // Добавляем класс для стилизации невалидного поля\r\n        } else {\r\n            elCheck = true;\r\n            el.classList.remove('validate'); // Удаляем класс для стилизации невалидного поля\r\n            el.parentElement.querySelector('.msg').style.display = 'none'; // Скрываем сообщение об успешной валидации\r\n        }\r\n    }\r\n\r\n    return {el, elCheck, value: el.value}; // Возвращаем результат проверки валидности значения в поле формы\r\n}\r\n\r\n/**\r\n * Функция для валидации поля ввода телефонного номера.\r\n * @param {HTMLElement} el - Элемент поля ввода.\r\n * @param {boolean} [isRequired=false] - Флаг, указывающий, является ли электронная почта обязательным полем.\r\n * @returns {Object} - Объект с элементом и флагом результата валидации.\r\n */\r\nfunction formPhoneValid(el, isRequired = false) {\r\n    // Регулярное выражение для проверки наличия цифр в строке\r\n    var validPhone = /\\d/;\r\n    // Получаем длину значения в поле ввода\r\n    var l = el.value.length;\r\n    let elCheck = true;\r\n\r\n    if (isRequired) {\r\n        // Проверка на пустое значение\r\n        if (l === 0) {\r\n            elCheck = false;\r\n            el.classList.add('validate');\r\n            el.parentElement.querySelector('.msg').style.display = 'none';\r\n            el.parentElement.querySelector('.msg-error').style.display = 'block';\r\n        } else {\r\n            // Если длина значения в поле ввода меньше 10 и больше 0\r\n            if (l < 10 && l > 0) {\r\n                elCheck = false;\r\n                el.classList.add('validate');\r\n                el.parentElement.querySelector('.msg').style.display = 'none';\r\n                el.parentElement.querySelector('.msg-empty').style.display = 'block';\r\n            } else {\r\n                elCheck = true;\r\n                el.classList.remove('validate');\r\n                el.parentElement.querySelector('.msg').style.display = 'none';\r\n            }\r\n        }\r\n    }\r\n    return {el, elCheck, value: el.value};\r\n} // конец\r\n\r\n/**\r\n * Функция для валидации поля ввода электронной почты.\r\n * @param {HTMLElement} el - Элемент поля ввода.\r\n * @param {boolean} [isRequired=false] - Флаг, указывающий, является ли электронная почта обязательным полем.\r\n * @returns {Object} - Объект с элементом и флагом результата валидации.\r\n */\r\nfunction formEmailValid(el, isRequired = false) {\r\n    let elCheck;\r\n    var emailVal = el.value; // Получаем значение электронной почты из поля ввода\r\n    var emailValid = emailVal.split('@'); // Разбиваем значение на две части по символу '@'\r\n    var l = el.value.length; // Получаем длину значения в поле ввода\r\n\r\n    // Если электронная почта обязательна для заполнения\r\n    if (isRequired) {\r\n        if (l === 0) {\r\n            el.classList.add('validate');\r\n            el.parentElement.querySelector('.msg').style.display = 'none';\r\n            el.parentElement.querySelector('.msg-error').style.display = 'block';\r\n            elCheck = false;\r\n        } else {\r\n            if (l > 0 && (el.value.match(/.+?\\@.+\\.+/g) || []).length === 1) {\r\n                if (emailValid[0].length < 3) {\r\n                    el.classList.add('validate');\r\n                    el.parentElement.querySelector('.msg').style.display = 'none';\r\n                    el.parentElement.querySelector('.msg-error-length').style.display = 'block';\r\n                    elCheck = false;\r\n                } else {\r\n                    el.classList.remove('validate');\r\n                    el.parentElement.querySelector('.msg').style.display = 'none';\r\n                    elCheck = true;\r\n                }\r\n            } else {\r\n                el.classList.add('validate');\r\n                el.parentElement.querySelector('.msg').style.display = 'none';\r\n                el.parentElement.querySelector('.msg-empty').style.display = 'block';\r\n                elCheck = false;\r\n            }\r\n        }\r\n    } else {\r\n        // Если электронная почта необязательна для заполнения\r\n        if (l > 0) {\r\n            if (l > 0 && (el.value.match(/.+?\\@.+\\.+/g) || []).length === 1) {\r\n                if (emailValid[0].length < 3) {\r\n                    el.classList.add('validate');\r\n                    el.parentElement.querySelector('.msg').style.display = 'none';\r\n                    el.parentElement.querySelector('.msg-error-length').style.display = 'block';\r\n                    elCheck = false;\r\n                } else {\r\n                    el.classList.remove('validate');\r\n                    el.parentElement.querySelector('.msg').style.display = 'none';\r\n                    elCheck = true;\r\n                }\r\n            } else {\r\n                el.classList.add('validate-border');\r\n                el.parentElement.querySelector('.msg').style.display = 'none';\r\n                el.parentElement.querySelector('.msg-error-email').style.display = 'block';\r\n                elCheck = false;\r\n            }\r\n        } else {\r\n            elCheck = true;\r\n        }\r\n    }\r\n\r\n    return {el, elCheck, value: el.value};\r\n} // конец\r\n\r\n/**\r\n * Функция для валидации поля ввода индекса.\r\n * @param {HTMLElement} el - Элемент поля ввода.\r\n * @param {boolean} [isRequired=false] - Флаг, указывающий, является ли электронная почта обязательным полем.\r\n * @returns {Object} - Объект с элементом и флагом результата валидации.\r\n */\r\nfunction formIndexValid(el, isRequired = false) {\r\n    let elCheck = true;\r\n    // Получаем длину значения в поле ввода\r\n    let l = el.value.length;\r\n\r\n    if (isRequired) {\r\n        // Проверяем, не пустое ли значение\r\n        if (l === 0) {\r\n            elCheck = false;\r\n            el.classList.add('validate');\r\n            el.parentElement.querySelector('.msg').style.display = 'none';\r\n            el.parentElement.querySelector('.msg-error').style.display = 'block';\r\n        } else if (l !== 0 && l < 6) { // Если значение не пустое, но длина меньше 6 символов\r\n            elCheck = false;\r\n            el.parentElement.querySelector('.msg').style.display = 'none';\r\n            el.parentElement.querySelector('.msg-empty').style.display = 'block';\r\n            el.classList.add('validate');\r\n        } else {\r\n            // Валидация пройдена\r\n            elCheck = true;\r\n            el.classList.remove('validate');\r\n            el.parentElement.querySelector('.msg').style.display = 'none';\r\n        }\r\n    }\r\n\r\n\r\n    return {el, elCheck, value: el.value};\r\n} // конец\r\n\r\n/**\r\n * Функция для валидации поля ввода адреса.\r\n * @param {HTMLElement} el - Элемент поля ввода.\r\n * @param {boolean} [isRequired=false] - Флаг, указывающий, является ли электронная почта обязательным полем.\r\n * @returns {Object} - Объект с элементом и флагом результата валидации.\r\n */\r\nfunction formAddressValid(el, isRequired = false) {\r\n    let elCheck = true;\r\n    // Получаем длину значения в поле ввода\r\n    let l = el.value.length;\r\n\r\n    if (isRequired) {\r\n        // Проверяем, не пустое ли значение\r\n        if (l === 0) {\r\n            elCheck = false;\r\n            el.classList.add('validate');\r\n            el.parentElement.querySelector('.msg').style.display = 'none';\r\n            el.parentElement.querySelector('.msg-error').style.display = 'block';\r\n        } else {\r\n            // Валидация пройдена\r\n            elCheck = true;\r\n            el.classList.remove('validate');\r\n            el.parentElement.querySelector('.msg').style.display = 'none';\r\n        }\r\n    }\r\n\r\n    return {el, elCheck, value: el.value};\r\n} // конец\r\n\r\n/**\r\n * Функция для валидации кастомного выпадающего списка.\r\n * @param {HTMLElement} el - Элемент кастомного выпадающего списка.\r\n * @param {boolean} isRequired - Флаг, указывающий, является ли заполнение списка обязательным.\r\n * @returns {Object} - Объект с элементом и флагом результата валидации.\r\n */\r\nfunction formCustomSelectValid(el, isRequired = false) {\r\n    let elCheck = true;\r\n    let value = '';\r\n    // Проверяем, является ли заполнение списка обязательным\r\n    if (isRequired) {\r\n        let parent = el.closest('.select-wrapper') || false; // Получаем родительский элемент списка\r\n        let title = el.querySelector('.select-title'); // Получаем заголовок списка\r\n        let inputs = el.querySelectorAll('input[type=\"radio\"]'); // Получаем все радио-кнопки в списке\r\n        let messages = parent ? parent.querySelectorAll('.msg') : {};\r\n\r\n        // Перебираем все радио-кнопки в списке\r\n        for (let i = 0; i < inputs.length; i++) {\r\n            let input = inputs[i];\r\n\r\n            if (input.checked && input.value !== '') {\r\n                value = input.value;\r\n                // Если хотя бы одна кнопка выбрана, считаем список валидным\r\n                elCheck = true;\r\n                // Убираем стиль валидации у заголовка\r\n                title.classList.remove('validate');\r\n                // Скрываем все сообщения об ошибках\r\n                if (messages.length > 0) {\r\n                    parent.querySelectorAll('.msg').forEach(item => item.style.display = 'none');\r\n                }\r\n\r\n                break;\r\n            } else {\r\n                // Если ни одна кнопка не выбрана, считаем список невалидным\r\n                elCheck = false;\r\n\r\n                // Добавляем стиль валидации к заголовку\r\n                title.classList.add('validate');\r\n                // Отображаем сообщение об ошибке\r\n                if (messages.length > 0) {\r\n                    parent.querySelector('.msg-error').style.display = 'block';\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return {el, elCheck, value};\r\n}\r\n\r\n/**\r\n * Проверяет валидность текстового поля.\r\n *\r\n * @param {HTMLElement} el Элемент textarea для проверки.\r\n * @param {boolean} isRequired Флаг, указывающий, является ли поле обязательным для заполнения (по умолчанию false).\r\n * @param {number} maxLength Максимальная длина текста в поле (по умолчанию 100).\r\n * @returns {object} Объект с элементом textarea и флагом валидности.\r\n */\r\nfunction formTextareaValid(el, isRequired = false, maxLength = 100) {\r\n    let elCheck = true;\r\n\r\n    if (isRequired) {\r\n        let l = el.value.length; // Получаем длину текста в поле ввода\r\n\r\n        // Если поле ввода пустое\r\n        if (l === 0) {\r\n            elCheck = false;\r\n            el.classList.add('validate');\r\n            el.parentElement.querySelector('.msg').style.display = 'none';\r\n            el.parentElement.querySelector('.msg-error').style.display = 'block';\r\n        } else if (l !== 0 && l < maxLength) {\r\n            // Если длина текста меньше максимальной длины\r\n            elCheck = false;\r\n            el.parentElement.querySelector('.msg').style.display = 'none';\r\n            el.parentElement.querySelector('.msg-empty').style.display = 'block';\r\n            el.classList.add('validate');\r\n        } else {\r\n            // Если длина текста соответствует или превышает максимальную длину\r\n            elCheck = true;\r\n            el.classList.remove('validate');\r\n            el.parentElement.querySelector('.msg').style.display = 'none';\r\n        }\r\n    }\r\n\r\n    // Возвращаем объект с элементом textarea и флагом валидности\r\n    return {el, elCheck, value: el.value};\r\n}\r\n\r\n/**\r\n * Функция для валидации чекбокса.\r\n * @param {HTMLElement} el - Элемент чекбокса.\r\n * @param {boolean} [isRequired=false] - Флаг, указывающий, является ли чекбокс обязательным для выбора.\r\n * @returns {Object} - Объект с элементом и флагом результата валидации.\r\n */\r\nfunction checkboxValid(el, isRequired = false) {\r\n    let elCheck = true;\r\n    // Убираем класс \"not-checked\" у родительского элемента\r\n    el.classList.remove('not-checked');\r\n\r\n    // Проверяем, является ли выбор чекбокса обязательным\r\n    if (isRequired) {\r\n        if (el.checked) {\r\n            // Если чекбокс выбран, считаем его валидным\r\n            elCheck = true;\r\n            // Убираем класс \"not-checked\" у родительского элемента\r\n            el.classList.remove('not-checked');\r\n        } else {\r\n            // Если чекбокс не выбран, считаем его невалидным\r\n            elCheck = false;\r\n            // Добавляем класс \"not-checked\" к родительскому элементу\r\n            el.classList.add('not-checked');\r\n        }\r\n    }\r\n\r\n    return {el, elCheck, value: el.value};\r\n}\r\n\r\n/**\r\n * Функция для валидации поля ввода промокода.\r\n * @param {HTMLElement} el - Элемент поля ввода промокода.\r\n * @param {boolean} isRequired - Флаг, указывающий, является ли поле обязательным для заполнения (по умолчанию false).\r\n * @returns {boolean} - Результат валидации поля.\r\n */\r\nfunction formPromocodeValid(el, isRequired = false) {\r\n    let elCheck; // Переменная для хранения результата валидации\r\n    const l = el.value.length; // Длина значения в поле ввода\r\n    const parent = el.parentElement;\r\n    const msgHidden = () => {\r\n        parent.querySelector('.msg-error').style.display = 'none'; // Скрытие сообщения об ошибке\r\n        parent.querySelector('.msg-error-not-apply').style.display = 'none'; // Скрытие сообщения о том, что промокод не применен\r\n        parent.querySelector('.msg-empty').style.display = 'none'; // Скрытие сообщения о том, что промокод некорректно введен\r\n    }\r\n\r\n\r\n    if (isRequired) {\r\n        // Проверка длины значения в поле ввода\r\n        if (l > 2) {\r\n            // Если длина значения больше 2\r\n\r\n            elCheck = true; // Установка результата валидации в true\r\n            msgHidden();\r\n            el.classList.remove('validate'); // Удаление класса \"validate\" у поля ввода\r\n        } else {\r\n            // Если длина значения меньше 2\r\n            elCheck = false; // Установка результата валидации в false\r\n            el.classList.add('validate'); // Добавление класса \"validate\" к полю ввода\r\n            msgHidden();\r\n            parent.querySelector('.msg-empty').style.display = 'block'; // Отображение сообщения о том, что промокод некорректно введен\r\n        }\r\n    } else {\r\n        elCheck = true; // Установка результата валидации в true\r\n        el.classList.remove('validate'); // Удаление класса \"validate\" у поля ввода\r\n        msgHidden();\r\n    }\r\n\r\n    return {el, elCheck, value: el.value}; // Возвращение результата валидации\r\n}\r\n\r\n;\r\nclass Accordion {\r\n    constructor(selector, multiple) {\r\n        this.el = typeof selector === 'string' ? document.querySelector(selector): selector;\r\n        this.multiple = multiple;\r\n\r\n        if (!this.el) return;\r\n\r\n        this.bindEvents();\r\n    }\r\n\r\n    bindEvents() {\r\n        const headings = this.el.querySelectorAll('.heading');\r\n        headings.forEach(heading => {\r\n            heading.addEventListener('click', () => {\r\n                const parent = heading.parentElement;\r\n\r\n                if (!this.multiple) {\r\n                    this.closeOthers(parent);\r\n                }\r\n\r\n                if (parent.classList.contains('open')) {\r\n                    this.close(parent);\r\n                } else {\r\n                    this.open(parent);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    open(element) {\r\n        element.classList.add('open');\r\n        // CSS транзиции обрабатывают изменения, поэтому JavaScript здесь изменяет только классы\r\n    }\r\n\r\n    close(element) {\r\n        element.classList.remove('open');\r\n        // Аналогично, плавное закрытие обрабатывается через CSS\r\n    }\r\n\r\n    closeOthers(currentElement) {\r\n        // Закрываем все аккордеоны, кроме текущего\r\n        const allElements = this.el.querySelectorAll('.accordion-item');\r\n        allElements.forEach(element => {\r\n            if (element !== currentElement) {\r\n                this.close(element);\r\n            }\r\n        });\r\n    }\r\n}\r\n;\r\n\r\n/**\r\n * Класс HandlerForm обрабатывает формы, выполняя валидацию полей перед отправкой.\r\n */\r\nclass HandlerForm {\r\n\r\n    /**\r\n     * Конструктор класса.\r\n     * @param {HTMLElement} form - HTML-форма, которую необходимо обработать.\r\n     * @param {boolean} autoSubmit - HTML-форма, которую необходимо обработать.\r\n     * @param {boolean} formReset - HTML-форма, которую необходимо обработать.\r\n     */\r\n    constructor({\r\n                    form,\r\n                    autoSubmit = false,\r\n                    formReset = true\r\n                }) {\r\n        // Если у формы есть класс 'not-valid', устанавливаем this.form как null, что отменяет дальнейшую инициализацию\r\n        this.form = form.classList.contains('not-valid') ? null : form;\r\n        this.autoSubmit = autoSubmit;\r\n        this.reset = formReset;\r\n\r\n        // Объект с функциями валидации для различных типов полей. Каждая функция проверяет корректность ввода в зависимости от типа поля.\r\n        this.validationFunctions = {\r\n            name: formNameValid, // Валидация имени\r\n            phone: formPhoneValid, // Валидация телефона\r\n            email: formEmailValid, // Валидация электронной почты\r\n            index: formIndexValid, // Валидация почтового индекса\r\n            address: formAddressValid, // Валидация адреса\r\n            agreement: checkboxValid, // Валидация чекбокса согласия\r\n            textarea: formTextareaValid, // Валидация текстового поля\r\n            promo: formPromocodeValid, // Валидация промокода\r\n            selects: formCustomSelectValid // Валидация настраиваемого select'а\r\n        };\r\n\r\n        // Массив полей, которые нужно исключить из основной валидации.\r\n        this.excludeFields = ['selects', 'inputs', 'submit', 'promoDelete', 'promoApply', 'textarea', 'agreement', 'subscribing'];\r\n\r\n        // Массив полей, которые являются чекбоксами и требуют особого подхода в валидации.\r\n        this.checkboxFields = ['subscribing', 'agreement', 'soglasie'];\r\n\r\n        // Если форма не прошла проверку в конструкторе, дальнейшая обработка не выполняется\r\n        if (this.form === null) {\r\n            return;\r\n        }\r\n\r\n        // Получаем все поля формы для дальнейшей валидации и обработки\r\n        this.fields = this.formFields(form);\r\n\r\n        // Инициализируем валидацию и обработчики для формы\r\n        this.init(this.form);\r\n    }\r\n\r\n    /**\r\n     * Метод инициализации формы.\r\n     * @param {HTMLElement} form - HTML-форма, которая будет инициализирована.\r\n     */\r\n    init(form) {\r\n        if (this.reset) {\r\n            // Сбрасываем форму, чтобы все поля вернулись к исходным значениям\r\n            form.reset();\r\n        }\r\n        // Проверяем, не была ли форма уже проинициализирована (если у формы есть класс 'on-validate', она уже обрабатывается).\r\n        if (!form.classList.contains('on-validate')) {\r\n            const fields = this.fields;\r\n            const submit = fields.submit;\r\n\r\n            // Добавляем обработчики валидации для каждого поля\r\n            this.validateFields(fields, this.fieldAddHandle);\r\n\r\n            if (this.autoSubmit) {\r\n                this.formAutoSubmit(form, fields);\r\n            } else {\r\n                // Удаляем все существующие обработчики события 'click' у кнопки отправки, если они были добавлены ранее\r\n                submit.onclick = null;\r\n\r\n                // Добавляем новый обработчик на кнопку отправки формы\r\n                submit.onclick = (event => this.submitHandler(event, form, fields));\r\n                // Добавляем класс 'on-validate', чтобы пометить форму как проинициализированную\r\n                form.classList.add('on-validate');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Обработчик отправки формы. Предотвращает стандартное действие (отправку формы)\r\n     * и вызывает функцию обработки и валидации полей формы.\r\n     *\r\n     * @param {Event} event - Событие отправки формы.\r\n     * @param {HTMLElement} form - HTML-форма, которая отправляется.\r\n     * @param {Object} fields - Объект, содержащий поля формы, которые были собраны и готовы для валидации.\r\n     */\r\n    submitHandler(event, form, fields) {\r\n        // Предотвращаем стандартное действие браузера (отправку формы)\r\n        event.preventDefault();\r\n\r\n        // Вызываем функцию для отправки формы с валидированными полями\r\n        this.formSubmit(form, fields);\r\n    }\r\n\r\n    /**\r\n     * Собирает все поля формы в объект для дальнейшей обработки и валидации.\r\n     *\r\n     * @param {HTMLElement} form - HTML-форма, из которой извлекаются поля.\r\n     * @returns {Object} fields - Объект, содержащий все нужные поля формы.\r\n     */\r\n    formFields(form) {\r\n        // Создаем объект для хранения полей формы\r\n        const fields = {};\r\n\r\n        /**\r\n         * Функция для добавления поля в объект, если соответствующий элемент существует в DOM.\r\n         *\r\n         * @param {string} name - Имя поля, которое будет использоваться как ключ в объекте fields.\r\n         * @param {string} selector - CSS-селектор для поиска элемента формы.\r\n         */\r\n        const addFieldIfExist = (name, selector) => {\r\n            const element = form.querySelector(selector); // Ищем элемент по селектору\r\n            if (element) {\r\n                fields[name] = element; // Если элемент найден, добавляем его в объект fields\r\n            }\r\n        };\r\n\r\n        // Добавление различных полей в объект fields с проверкой на существование элементов\r\n        addFieldIfExist('name', '.input-name'); // Поле имени\r\n        addFieldIfExist('phone', '.input-phone'); // Поле телефона\r\n        addFieldIfExist('email', '.input-email'); // Поле email\r\n        addFieldIfExist('index', '.input-index'); // Поле индекса\r\n        addFieldIfExist('address', '.input-address'); // Поле адреса\r\n        addFieldIfExist('promo', '.input-promocode'); // Поле промокода\r\n        addFieldIfExist('agreement', 'input[type=\"checkbox\"][name=\"agreement\"]'); // Чекбокс согласия\r\n        addFieldIfExist('subscribing', 'input[type=\"checkbox\"][name=\"permission_mailing\"]'); // Чекбокс подписки на рассылку\r\n        addFieldIfExist('promoApply', '.promocode__btn_apply'); // Кнопка применения промокода\r\n        addFieldIfExist('promoDelete', '.promocode__btn_delete'); // Кнопка удаления промокода\r\n        addFieldIfExist('textarea', 'textarea'); // Текстовое поле\r\n        addFieldIfExist('submit', 'input[type=\"submit\"]'); // Кнопка отправки (input)\r\n        addFieldIfExist('submit', 'button[type=\"submit\"]'); // Кнопка отправки (button)\r\n\r\n        // Сбор всех input-элементов (кроме submit, hidden, radio и checkbox) и textarea\r\n        fields.inputs = form.querySelectorAll('input:not([type=\"submit\"]):not([type=\"hidden\"]):not([type=\"radio\"]):not([type=\"checkbox\"]), textarea');\r\n\r\n        // Сбор всех элементов select с кастомным дизайном\r\n        fields.selects = form.querySelectorAll('.custom-select');\r\n\r\n        // Возвращаем объект fields, содержащий все собранные поля\r\n        return fields;\r\n    }\r\n\r\n    /**\r\n     * Функция для валидации полей формы. Добавляет обработчики событий для валидации\r\n     * каждого поля на основе переданных параметров и типа поля.\r\n     *\r\n     * @param {Object} fields - Объект, содержащий поля формы. Каждое поле представлено как свойство объекта.\r\n     * @param {Function} handler - Функция-обработчик, которая добавляет необходимые события для валидации.\r\n     * @returns {Object} validationResult - Объект с результатами валидации полей формы. Содержит информацию о каждом валидированном поле.\r\n     */\r\n    validateFields(fields, handler) {\r\n        const excludeFields = this.excludeFields;  // Поля, которые не нужно валидировать\r\n        const checkboxFields = this.checkboxFields; // Поля типа чекбоксов\r\n        const validationResult = {}; // Объект для хранения результатов валидации\r\n\r\n        // Проходим по всем полям формы\r\n        for (const key in fields) {\r\n            const field = fields[key]; // Текущее поле формы\r\n            this.getFieldsProps({\r\n                key,\r\n                validationResult,\r\n                excludeFields,\r\n                checkboxFields,\r\n                handler,\r\n                field\r\n            });\r\n        }\r\n\r\n\r\n        return validationResult; // Возвращаем результаты валидации\r\n    }\r\n\r\n    getFieldsProps(props) {\r\n        const {key, validationResult, excludeFields, checkboxFields, handler, field} = props;\r\n        const validate = this.validationFunctions[key] || new Function(); // Функция валидации для данного поля, если не найдена, используем пустую функцию\r\n        let result = undefined; // Результат валидации текущего поля\r\n\r\n        // Параметры для передачи в функцию-обработчик валидации\r\n        const myProps = {\r\n            listener: 'blur', // По умолчанию, слушаем событие потери фокуса (blur)\r\n            field: field, // Текущее поле формы\r\n            validate: validate, // Функция валидации для этого поля\r\n            isMessage: false, // Специфическая настройка для текстового поля (textarea)\r\n            messageLength: 100, // Максимальная длина сообщения\r\n            isSelect: false // Специфическая настройка для кастомных select-элементов\r\n        };\r\n\r\n        // Проверка, не является ли поле исключением для валидации\r\n        if (!excludeFields.includes(key)) {\r\n            // Передаем параметры в обработчик валидации\r\n            result = handler(myProps);\r\n        }\r\n\r\n        // Если поле является чекбоксом, меняем событие на 'change'\r\n        if (checkboxFields.includes(key)) {\r\n            myProps.listener = 'change';\r\n            result = handler(myProps);\r\n        }\r\n\r\n        // Для поля типа textarea включаем специальную обработку сообщений\r\n        if (key === 'textarea') {\r\n            myProps.isMessage = true;\r\n            result = handler(myProps);\r\n        }\r\n\r\n        // Для поля типа input promo делаем обработчик keyup\r\n        if (key === 'promo') {\r\n            myProps.listener = 'keyup';\r\n            result = handler(myProps);\r\n        }\r\n\r\n        // Для select-элементов с кастомной стилизацией\r\n        if (key === 'selects' && field.length > 0) {\r\n            myProps.isSelect = true;\r\n            result = handler(myProps);\r\n        }\r\n\r\n        // Если обработчик вернул результат, добавляем его в объект результатов\r\n        if (typeof result !== 'undefined') {\r\n            Object.assign(validationResult, result); // Добавляем результат в объект validationResult\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Функция для добавления обработчика события к полю формы, основанного на типе поля и его валидации.\r\n     * Добавляет обработчики для событий потери фокуса ('blur') или изменения ('change') для полей формы.\r\n     *\r\n     * @param {Object} props - Объект с параметрами для обработчика.\r\n     * @param {string} props.listener - Тип события, на которое нужно реагировать (например, 'blur' или 'change').\r\n     * @param {HTMLElement | NodeList} props.field - HTML-элемент или коллекция элементов (NodeList), к которым будет привязан обработчик.\r\n     * @param {Function} props.validate - Функция для валидации поля. Эта функция принимает поле и опциональные параметры, такие как флаг обязательности и длина сообщения.\r\n     * @param {boolean} [props.isMessage=false] - Флаг, указывающий, нужно ли выводить сообщение об ошибке для поля (например, для текстовых полей).\r\n     * @param {number} [props.messageLength=100] - Максимальная длина сообщения об ошибке (применимо для полей, где выводятся ошибки).\r\n     * @param {boolean} [props.isSelect=false] - Флаг, указывающий, что поле является выпадающим списком (select) и требует особого подхода.\r\n     */\r\n    fieldAddHandle(props) {\r\n        const {listener, field, validate, isMessage = false, messageLength = 100, isSelect = false} = props;\r\n\r\n        // Проверка, является ли поле выпадающим списком (select)\r\n        if (isSelect) {\r\n            field.forEach(select => {\r\n                const isCustom = select.classList.contains('custom-select'); // Определяем, кастомный ли select\r\n                const isRequired = isCustom ? select.classList.contains('required') : select.required; // Проверка, является ли select обязательным\r\n\r\n                // Если это кастомный select\r\n                if (isCustom) {\r\n                    const options = select.querySelectorAll('.select-content__wrapper'); // Получаем все опции кастомного select\r\n                    // Добавляем обработчики кликов для каждой опции\r\n                    options.forEach(option => {\r\n                        option.addEventListener('click', event => {\r\n                            validate(select, isRequired); // Валидируем поле при выборе опции\r\n                        });\r\n                    });\r\n                }\r\n            });\r\n        } else {\r\n            // Для всех остальных полей добавляем обработчик на событие (blur или change)\r\n            field.addEventListener(listener, event => {\r\n                const isRequired = field.classList.contains('required'); // Проверяем, является ли поле обязательным\r\n\r\n                // Если нужно выводить сообщение (например, для textarea)\r\n                if (isMessage) {\r\n                    validate(field, isRequired, messageLength); // Валидируем поле с указанием максимальной длины сообщения\r\n                    return;\r\n                }\r\n\r\n                validate(field, isRequired); // Валидируем поле без сообщения\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Функция для проверки и валидации полей формы при потере фокуса или изменении поля.\r\n     * В зависимости от типа поля (input, textarea, select) применяются различные параметры валидации.\r\n     *\r\n     * @param {Object} props - Объект с параметрами для валидации и обработчика события.\r\n     * @param {HTMLElement | NodeList} props.field - HTML-элемент (input, textarea, select) или коллекция элементов (NodeList), которые нужно валидировать.\r\n     * @param {Function} props.validate - Функция для валидации поля. Эта функция принимает поле, флаг обязательности и длину сообщения (если применимо).\r\n     * @param {boolean} [props.isMessage=false] - Флаг, указывающий, что поле выводит сообщение об ошибке (например, textarea).\r\n     * @param {number} [props.messageLength=100] - Максимальная длина сообщения об ошибке (применимо для полей с сообщениями об ошибке).\r\n     * @param {boolean} [props.isSelect=false] - Флаг, указывающий, что поле является выпадающим списком (select) и требует особого подхода.\r\n     *\r\n     * @returns {Object} - Объект с результатами валидации полей. Ключи - это имена полей, значения - результаты валидации.\r\n     */\r\n    fieldCheckValidation(props) {\r\n        const {listener, field, validate, isMessage = false, messageLength = 100, isSelect = false} = props;\r\n        const validationResult = {}; // Объект для хранения результатов валидации\r\n        // Проверка на то, является ли поле выпадающим списком (select)\r\n        if (isSelect) {\r\n            field.forEach(select => {\r\n                const isCustom = select.classList.contains('custom-select'); // Проверка, кастомный ли это select\r\n                const isRequired = isCustom ? select.classList.contains('required') : select.required; // Проверка обязательности поля\r\n\r\n                if (isCustom) {\r\n                    const option = select.querySelector('input'); // Получаем input внутри кастомного select\r\n                    const selectName = option.name; // Имя поля select\r\n\r\n                    // Валидируем поле и записываем результат в объект validationResult\r\n                    validationResult[selectName] = validate(select, isRequired);\r\n                }\r\n            });\r\n        } else {\r\n            // Для остальных полей (input, textarea)\r\n            const isRequired = field.classList.contains('required'); // Проверка, является ли поле обязательным\r\n            const fieldName = field.name; // Получаем имя поля\r\n\r\n            // Проверка, нужно ли выводить сообщение для поля (например, textarea)\r\n            if (isMessage) {\r\n                validationResult[fieldName] = validate(field, isRequired, messageLength); // Валидируем с указанием длины сообщения\r\n            } else {\r\n                validationResult[fieldName] = validate(field, isRequired); // Валидируем без сообщения\r\n            }\r\n        }\r\n\r\n        return validationResult; // Возвращаем объект с результатами валидации\r\n    }\r\n\r\n    /**\r\n     * Функция для обработки и отправки формы.\r\n     * Выполняет валидацию полей, собирает значения полей и отправляет данные, если ошибок валидации нет.\r\n     *\r\n     * @param {HTMLFormElement} form - Форма, которую нужно отправить.\r\n     * @param {Object} fields - Объект, содержащий все поля формы.\r\n     */\r\n    formSubmit(form, fields) {\r\n        // Выполняем валидацию всех полей формы и получаем результат.\r\n        // Валидация выполняется через метод validateFields, который проверяет поля и возвращает объект с результатами.\r\n        const validation = this.validateFields(fields, this.fieldCheckValidation);\r\n        // Проверяем, есть ли ошибки в результате валидации.\r\n        // validationErrors возвращает объект с найденными ошибками валидации.\r\n        const validationErrors = this.validationErrors(validation);\r\n\r\n        // Получаем значения всех полей, которые прошли валидацию, с помощью метода getFieldsValues.\r\n        const fieldsValues = this.getFieldsValues(validation);\r\n\r\n        // Если объект validationErrors не пустой, значит есть ошибки, и мы прекращаем дальнейшую обработку.\r\n        if (JSON.stringify(validationErrors) !== '{}') {\r\n            return; // Прерываем отправку формы, если найдены ошибки\r\n        }\r\n\r\n        // Если ошибок нет, выводим значения полей в консоль (для отладки) и отправляем форму.\r\n        // console.log(fieldsValues);\r\n        const formData = new FormData(form);\r\n        formData.append('isAutoSubmit', this.autoSubmit);\r\n\r\n\r\n        // Создаем новый экземпляр класса FormSender, который отправит данные формы на сервер.\r\n        new FormSender(this.form, fieldsValues, formData);\r\n    }\r\n\r\n    formAutoSubmit(form, fields) {\r\n        const requiredFields = form.querySelectorAll('.required, [required]');\r\n        const excludeFields = this.excludeFields;  // Поля, которые не нужно валидировать\r\n        const checkboxFields = this.checkboxFields; // Поля типа чекбоксов\r\n        const validationResult = {}; // Объект для хранения результатов валидации\r\n        const handler = this.fieldCheckValidation;\r\n\r\n        const checkOnChange = (event) => {\r\n            const field = event.target;\r\n\r\n            this.getFieldsProps({\r\n                key: field.name,\r\n                validationResult,\r\n                excludeFields,\r\n                checkboxFields,\r\n                handler,\r\n                field\r\n            })\r\n\r\n            if (Object.keys(validationResult).length === requiredFields.length) {\r\n                this.formSubmit(form, fields);\r\n            }\r\n        }\r\n\r\n        requiredFields.forEach(field => {\r\n            field.addEventListener('change', checkOnChange);\r\n            field.addEventListener('blur', checkOnChange);\r\n        })\r\n    }\r\n\r\n\r\n    /**\r\n     * Функция для проверки полей на наличие ошибок валидации.\r\n     * Проходит по каждому полю и проверяет, если ли у поля свойство `elCheck` и является ли оно ложным (ошибка валидации).\r\n     *\r\n     * @param {Object} fields - Объект, содержащий все поля формы.\r\n     * @returns {Object} - Объект, содержащий только те поля, которые не прошли проверку валидации (с ошибками).\r\n     */\r\n    validationErrors(fields) {\r\n        const checkValues = {};\r\n\r\n        // Перебираем все ключи в объекте полей формы\r\n        for (let key in fields) {\r\n            const field = fields[key];\r\n            // Проверяем, существует ли свойство 'elCheck' у поля и имеет ли оно значение false (невалидное поле)\r\n            if ('elCheck' in field && !field.elCheck) {\r\n                // Если поле не прошло валидацию, добавляем его в объект ошибок\r\n                checkValues[key] = field.elCheck;\r\n            }\r\n        }\r\n\r\n        return checkValues; // Возвращаем объект с полями, которые не прошли проверку\r\n    }\r\n\r\n    /**\r\n     * Функция для извлечения значений всех полей формы.\r\n     * Проходит по каждому полю формы и собирает его значение.\r\n     *\r\n     * @param {Object} fields - Объект, содержащий все поля формы.\r\n     * @returns {Object} - Объект, содержащий названия полей и их значения.\r\n     */\r\n    getFieldsValues(fields) {\r\n        const values = {};\r\n\r\n        // Перебираем все ключи в объекте полей формы\r\n        for (let key in fields) {\r\n            const field = fields[key];\r\n            // Проверяем, содержит ли поле свойство 'value', чтобы получить его значение\r\n            if ('value' in field) {\r\n                values[key] = field.value; // Сохраняем значение поля в объекте\r\n            }\r\n        }\r\n\r\n        return values; // Возвращаем объект с полями и их значениями\r\n    }\r\n\r\n}\r\n\r\n/**\n * Создает экземпляр класса для обработки отправки формы.\n * @param {HTMLElement} form - HTML-элемент формы.\n * @param {object} data - Данные для отправки с формой.\n */\nclass FormSender {\n    constructor(form, data, formData) {\n        this.form = form; // HTML-элемент формы\n        this.data = data; // Данные для отправки с формой\n        this.formData = formData || {};\n        this.props = { // Создание объекта с параметрами для отправки запроса\n            data: this.data, // Данные для отправки с формой\n            form: this.form, // HTML-элемент формы\n        };\n\n        // Инициализация обработчика формы\n        this.init(this.form);\n    }\n\n    /**\n     * Инициализирует обработчик формы в зависимости от ее идентификатора.\n     * @param {HTMLElement} form - HTML-элемент формы.\n     */\n    init(form) {\n        let myProps;\n        // URL для отправки запроса с проверкой существования переменной\n        this.props.url = (typeof astrooma !== 'undefined' && dr_martynenko.ajaxurl)\n            ? dr_martynenko.ajaxurl\n            : 'https://jsonplaceholder.typicode.com/posts';\n\n\n        if (JSON.parse(this.formData.get('isAutoSubmit'))) {\n            myProps = this.getFormProps(this.props, this.formData);\n            myProps.action = 'crm_send';\n\n            // console.log('myProps', myProps);\n\n            // Получение функций обратного вызова для обработки результатов отправки формы обратной связи\n            Object.assign(myProps, this.autoSubmit());\n            this.sendFormPost(myProps);\n\n            return;\n        }\n\n        if (form.id) {\n            // Определение действий в зависимости от идентификатора формы\n            switch (form.id) {\n\n                default:\n                    myProps = this.getFormProps(this.props, this.formData);\n                    myProps.action = '#'; // Установка действия для формы\n                    // Получение функций обратного вызова для обработки результатов отправки формы бронирования\n                    Object.assign(myProps, this.defaultForm());\n                    // Отправка формы методом POST с использованием функций обратного вызова\n                    this.sendFormPost(myProps);\n            }\n        } else {\n            // Получаем класс формы\n            const formClass = form.classList.contains('feedback__form') ? 'feedback_form' :\n                'default_form';\n\n            switch (formClass) {\n                case 'feedback_form':\n                    props.action = 'base_request'; // Установка действия для формы\n                    props.showDescription = true; // Показывать описание модального окна\n                    props.requestType = 'callback' // Тип формы, с которой была отправлена заявка\n                    // Получение функций обратного вызова для обработки результатов отправки формы бронирования\n                    Object.assign(props, this.baseRequest());\n                    // Отправка формы методом POST с использованием функций обратного вызова\n                    this.sendFormPost(props);\n                    break;\n\n                case 'default_form':\n                default:\n                    props.action = '#'; // Установка действия для формы\n                    // Получение функций обратного вызова для обработки результатов отправки формы обратной связи (не модальное окно)\n                    Object.assign(props, this.defaultForm());\n                    // Отправка формы методом POST с использованием функций обратного вызова\n                    this.sendFormPost(props);\n            }\n        }\n    }\n\n    /**\n     * Создает объект с функциями обратного вызова для обработки результатов отправки формы.\n     * @returns {object} - Объект с функциями обратного вызова.\n     */\n    autoSubmit() {\n        /**\n         * Функция вызывается перед отправкой запроса и добавляет класс 'loader' к элементу body для отображения индикатора загрузки.\n         */\n        const beforeSend = (form) => {\n            const submitBtn = form.querySelector('.form-submit');\n            submitBtn.classList.add('load');\n        };\n\n        /**\n         * Функция вызывается при успешном ответе от сервера и обрабатывает полученные данные.\n         * @param {object} response - Ответ от сервера.\n         * @param {HTMLElement} form - Форма, связанная с запросом.\n         * @param {boolean} [showDescription=true] - Флаг, указывающий, нужно ли отображать описание модального окна.\n         */\n        const success = (response, form, showDescription = true) => {\n            const dealId = response['response'][0]['id'];\n            const dealIdInput = document.createElement('input');\n            dealIdInput.type = 'hidden';\n            dealIdInput.value = dealId;\n            dealIdInput.name = 'deal_id';\n\n            // console.log(dealIdInput);\n\n            form.append(dealIdInput);\n\n            new HandlerForm({\n                form,\n                formReset: false\n            });\n        };\n\n        /**\n         * Функция вызывается при возникновении ошибки во время запроса и обрабатывает ошибку.\n         * @param {XMLHttpRequest} xhr - Объект XMLHttpRequest, содержащий информацию о запросе.\n         * @param {string} exception - Строка, содержащая описание типа ошибки.\n         */\n        const onError = (xhr, exception) => this.ajaxErrors(xhr, exception);\n\n        /**\n         * Функция вызывается после завершения выполнения запроса и удаляет класс 'loader' у элемента body для скрытия индикатора загрузки.\n         */\n        const onComplete = (form) => {\n            const submitBtn = form.querySelector('.form-submit');\n            submitBtn.classList.remove('load');\n        };\n\n        // Возвращаем объект с функциями обратного вызова\n        return {beforeSend, success, onError, onComplete};\n    }\n\n    defaultForm() {\n        /**\n         * Функция вызывается перед отправкой запроса и добавляет класс 'loader' к элементу body для отображения индикатора загрузки.\n         */\n        const beforeSend = () => document.body.classList.add('loader');\n\n        /**\n         * Функция вызывается при успешном ответе от сервера и обрабатывает полученные данные.\n         * @param {object} response - Ответ от сервера.\n         * @param {HTMLElement} form - Форма, связанная с запросом.\n         */\n        const success = (response, form) => {\n            // console.log(response);\n            if (response.code === 200) {\n                const modal = form.closest('.modal');\n                const thxModal = document.getElementById('modal_lead_thx');\n\n                fadeOut(modal, 0);\n                fadeIn(thxModal, 215);\n            }\n        };\n\n        /**\n         * Функция вызывается при возникновении ошибки во время запроса и обрабатывает ошибку.\n         * @param {XMLHttpRequest} xhr - Объект XMLHttpRequest, содержащий информацию о запросе.\n         * @param {string} exception - Строка, содержащая описание типа ошибки.\n         */\n        const onError = (xhr, exception) => this.ajaxErrors(xhr, exception);\n\n        /**\n         * Функция вызывается после завершения выполнения запроса и удаляет класс 'loader' у элемента body для скрытия индикатора загрузки.\n         */\n        const onComplete = () => document.body.classList.remove('loader');\n\n        // Возвращаем объект с функциями обратного вызова\n        return {beforeSend, success, onError, onComplete};\n    }\n\n    /**\n     * Функция отправки POST запроса на сервер с использованием fetch.\n     * @param {object} props - Объект параметров запроса.\n     * @param {string} props.action - Действие, которое будет отправлено на сервер.\n     * @param {string} [props.url='https://jsonplaceholder.typicode.com/posts'] - URL, на который будет отправлен запрос.\n     * @param {object} [props.data={}] - Данные, которые будут отправлены на сервер.\n     * @param {function} [props.beforeSend=new Function()] - Функция, вызываемая перед отправкой запроса.\n     * @param {function} [props.success=new Function()] - Функция, вызываемая при успешном ответе от сервера.\n     * @param {function} [props.onError=new Function()] - Функция, вызываемая при возникновении ошибки во время запроса.\n     * @param {function} [props.onComplete=new Function()] - Функция, вызываемая после завершения запроса.\n     * @param {boolean} [props.showDescription=false] - Флаг, указывающий, нужно ли отображать описание запроса.\n     * @param {string} [props.form=''] - Форма, связанная с запросом.\n     */\n    sendFormPost(props) {\n        const {\n            action = '#',\n            url,\n            data = {},\n            beforeSend = new Function(),\n            success = new Function(),\n            onError = new Function(),\n            onComplete = new Function(),\n            showDescription,\n            form = ''\n        } = props;\n\n        /**\n         * Тип формы, с которой была отправлена заявка\n         * Локально для проекта\n         */\n            // data.requestType = props.requestType;\n\n            // Формируем объект данных для отправки на сервер, включая действие (action), если оно указано\n        const requestData = {action, ...data};\n\n        // Создаем объект FormData и добавляем в него данные из requestData\n        const formData = new FormData();\n        for (const key in requestData) {\n            formData.append(key, requestData[key]);\n        }\n        // console.log(formData)\n        // Параметры запроса\n        const requestOptions = {\n            method: 'POST',\n            body: formData\n        };\n\n        // Вызываем функцию beforeSend перед отправкой запроса\n        beforeSend(form);\n\n        // Отправляем запрос с использованием fetch\n        fetch(url, requestOptions)\n            .then(response => {\n                // Проверяем, был ли успешный ответ от сервера\n                if (!response.ok) {\n                    // throw new Error('Network response was not ok');\n                    throw new Error('Нет соединения. Проверьте сеть.');\n                }\n                // Проверяем, что ответ не пустой\n                if (response.status === 204) {\n                    // Возвращаем пустой объект данных, если ответ пустой\n                    return {};\n                }\n                // console.log(response)\n                // Возвращаем JSON-представление ответа\n                return response.json();\n            })\n            .then(data => {\n                // Вызываем функцию success при успешном ответе от сервера и передаем ей полученные данные\n                success(data, form, showDescription);\n            })\n            .catch(error => {\n                // Вызываем функцию onError при возникновении ошибки и передаем ей объект ошибки\n                onError(error);\n            })\n            .finally(() => {\n                // Вызываем функцию onComplete после завершения выполнения запроса\n                onComplete(form);\n            });\n    }\n\n    getFormProps(props, formData) {\n        const data = {};\n\n        for (let [key, value] of formData.entries()) {\n            switch (key) {\n                case 'phone':\n                    key = 'user_phone';\n\n                    break;\n\n                case 'name':\n                    key = 'user_name';\n\n                    break;\n\n                case 'email':\n                    key = 'user_email';\n\n                    break;\n\n                case 'product':\n                    key = 'post_id';\n\n                    break;\n\n                case 'isAutoSubmit':\n                    key = 'is_auto_submit';\n\n                    break;\n\n                case 'package_key':\n                    key = 'key';\n\n                    break;\n\n                case 'request_type':\n                    key = 'product';\n\n                    break;\n\n                case 'review_photo':\n                    key = 'user_photo';\n\n                    break;\n\n                case 'promo':\n                    if (value.length > 0) {\n                        const promocodeText = value.split(' ');\n                        key = 'promocode_text';\n                        value = promocodeText[1];\n                    }\n\n                    break;\n            }\n\n            // Добавление в data\n            if (value instanceof File) {\n                data[key] = value; // Сохраняем файл как есть\n            } else if (value && value.length > 0) {\n                data[key] = value; // Сохраняем строковые значения\n            }\n        }\n\n        // console.log('data', data);\n\n        props.data = data;\n\n        // console.log('props', props)\n\n        return props;\n    }\n\n    // обработка ошибок ajax\n    /**\n     * Функция для обработки ошибок при выполнении AJAX-запроса.\n     * @param {XMLHttpRequest} xhr - Объект XMLHttpRequest, содержащий информацию о запросе.\n     * @param {string} [exception=''] - Строка с описанием типа ошибки.\n     */\n    ajaxErrors(xhr, exception = '') {\n        // Вывод информации о запросе в консоль для отладки\n        console.log(xhr);\n\n        // Обработка различных типов ошибок\n        if (xhr.status === 0) {\n            // Ошибка при отсутствии соединения\n            console.error('Нет соединения. Проверьте сеть.');\n        } else if (xhr.status === 404) {\n            // Ошибка 404: страница не найдена\n            console.error('Запрошенная страница не найдена (404).');\n        } else if (xhr.status === 500) {\n            // Ошибка 500: внутренняя ошибка сервера\n            console.error('Внутренняя ошибка сервера (500).');\n        } else if (exception === 'parsererror') {\n            // Ошибка при синтаксическом анализе JSON\n            console.error('Не удалось выполнить запрошенный синтаксический анализ JSON. (parse failed)');\n        } else if (exception === 'timeout') {\n            // Превышен лимит времени ожидания запроса\n            console.error('Превышен лимит времени на запрос.');\n        } else if (exception === 'abort') {\n            // Запрос был прерван\n            console.error('Запрос прерван.');\n        } else {\n            // Обработка неопределенной ошибки\n            console.error('Неопределенная ошибка. ' + xhr.responseText);\n            console.error('Убрать с обработчика на бекенде все дебаги и повторить');\n        }\n    }\n}\n\r\n\r\ndocument.addEventListener('DOMContentLoaded', function () {\r\n    // Получаем основной элемент body\r\n    const mainBody = document.querySelector('body');\r\n// Получаем высоту заголовка\r\n    const header = document.getElementById('header');\r\n// Получаем высоту подвала\r\n    const footer = document.querySelector('footer');\r\n// Получаем основной элемент main\r\n    const main = document.querySelector('main');\r\n    const desktop = 1201;\r\n    const laptop = 1200.98;\r\n    const tablet = 1029.98;\r\n    const mobile = 807.98;\r\n    const fullMobile = 575.98;\r\n    const clientWidth = document.documentElement.clientWidth;\r\n    const contentWrapWidth = calculateDynamicValue({\r\n        desktop: 1160,\r\n        laptop: 990,\r\n        tablet: 740,\r\n        mobile: clientWidth - 20\r\n    });\r\n\r\n    /**\r\n     * Рассчитывает динамическое значение в зависимости от переданных параметров и ширины окна браузера.\r\n     * @param {Object} values - Объект с значениями для разных ширин экрана.\r\n     * @param {number} values.desktop - Значение для ширины экрана больше 1201 пикселя.\r\n     * @param {number} values.laptop - Значение для ширины экрана между 1200 и 1029 пикселями.\r\n     * @param {number} values.tablet - Значение для ширины экрана между 1029 и 807 пикселями.\r\n     * @param {number} values.mobile - Значение для ширины экрана менее 807 пикселей.\r\n     * @returns {*} - Рассчитанное динамическое значение.\r\n     */\r\n\r\n    function calculateDynamicValue(values) {\r\n        let value;\r\n\r\n        if (clientWidth > desktop) {\r\n            value = values['desktop'];\r\n        } else if (clientWidth >= tablet && clientWidth < laptop) {\r\n            value = values['laptop'];\r\n        } else if (clientWidth >= mobile && clientWidth < tablet) {\r\n            value = values['tablet'];\r\n        } else if (clientWidth < mobile) {\r\n            value = values['mobile']\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n// Растягиваем основной элемент main между заголовком и подвалом\r\n    const headerHeight = header.offsetHeight; // Получаем высоту заголовка\r\n    const footerHeight = footer.offsetHeight; // Получаем высоту подвала\r\n    main.style.minHeight = `calc(100vh - (${headerHeight}px + ${footerHeight}px))`; // Устанавливаем минимальную высоту основного элемента main\r\n\r\n    // шапка\r\n    /**\n * Функция для управления состоянием меню в зависимости от прокрутки страницы.\n *\n * @param {Object} item - Объект window, который содержит информацию о текущей прокрутке страницы.\n * @param {Boolean} onScroll - Флаг, указывающий, что вызвана функция при скролле.\n */\nfunction stickyMenu(item, onScroll = false) {\n    // Получаем первый секционный элемент внутри main\n    const hero = document.body.querySelector('main > section');\n    // Получаем высоту этого секционного элемента\n    const heroH = hero.offsetHeight;\n    // Получаем элемент с id 'header'\n    const header = document.getElementById('header');\n    // Получаем фиксированное меню внутри header\n    const headerFixed = header.querySelector('.header__fixed');\n    // Получаем основное меню внутри header\n    const headerMain = header.querySelector('.header__main');\n\n    // Если текущая прокрутка страницы больше высоты секционного элемента\n    if (item.pageYOffset > heroH) {\n        // Добавляем класс nav_scroll к body\n        document.body.classList.add('nav_scroll');\n        // Меняем классы для анимации фиксированного меню\n        headerFixed.classList.remove('slideInLeft');\n        headerFixed.classList.add('slideOutLeft');\n\n        // Меняем классы для анимации основного меню\n        headerMain.classList.add('slideInDown');\n        headerMain.classList.remove('slideOutDown');\n    } else {\n        // Если прокрутка меньше высоты секционного элемента, удаляем класс nav_scroll у body\n        document.body.classList.remove('nav_scroll');\n\n        // Меняем классы для анимации фиксированного меню\n        headerFixed.classList.remove('slideOutLeft');\n        headerFixed.classList.add('slideInLeft');\n\n        headerMain.classList.add('slideOutUp');\n        headerMain.classList.remove('slideInDown');\n    }\n}\n\n// Вызываем функцию stickyMenu при загрузке страницы с текущим объектом window\n// stickyMenu(window);\n\n// Добавляем обработчик события прокрутки страницы\n// window.addEventListener('scroll', function () {\n//     // Вызываем функцию stickyMenu при каждом событии прокрутки\n//     stickyMenu(this, true);\n// });\n\n// Добавляем обработчик события клика на документ\n// document.addEventListener('click', e => {\n//     // Получаем элемент фиксированного меню\n//     const element = document.querySelector('.header__fixed');\n//     // Получаем кнопку гамбургера\n//     const button = document.querySelector('.header__hamburger');\n//\n//     // Определяем на какой элемент был клик\n//     const target = e.target;\n//     // Проверяем, был ли клик на фиксированное меню или внутри него\n//     const itsEl = target === element || element.contains(target);\n//     // Проверяем, был ли клик на кнопку гамбургера\n//     const itsHamburger = target === button;\n//     // Проверяем, открыт ли элемент (имеет ли он класс open)\n//     const isElementOpen = button.classList.contains('open');\n//\n//     // Если клик был не на фиксированное меню, не на кнопку гамбургера и меню открыто\n//     if (!itsEl && !itsHamburger && isElementOpen) {\n//         // Убираем класс no-scroll у body (возвращаем прокрутку страницы)\n//         document.body.classList.remove('no-scroll');\n//         // Убираем класс open у кнопки гамбургера\n//         button.classList.remove('open');\n//         // Добавляем класс close у кнопки гамбургера\n//         button.classList.add('close');\n//         // Меняем классы для анимации фиксированного меню\n//         element.classList.remove('slideInLeft');\n//         element.classList.add('slideOutLeft');\n//     }\n// });\n\nconst headerCatalogOpenBtn = document.querySelector('.header__catalog-open');\nconst headerCatalog = document.querySelector('.header__catalog-menu');\n\nif (headerCatalogOpenBtn) {\n    headerCatalogOpenBtn.addEventListener('click', (event) => {\n        headerCatalog.classList.toggle('open');\n        headerCatalogOpenBtn.classList.toggle('open');\n    });\n}\n\nif (headerCatalog) {\n    const catalogLists = document.querySelectorAll('.catalog-menu-list');\n\n    if (catalogLists.length > 0) {\n\n        const getParentListAndCategory = (target) => {\n            const listItem = target.classList.contains('menu-list__item') ? target : target.closest('.menu-list__item');\n            const parentList = listItem.closest('.catalog-menu-list');\n            const category = listItem.dataset.category;\n            const submenuClass = parentList.classList.contains('submenu-1') ? '.catalog-menu-list.submenu.submenu-2' : '.catalog-menu-list.submenu.submenu-1';\n\n            return {submenuClass, category};\n        };\n\n        const toggleSubMenu = ({submenuClass, category, show, listItem}) => {\n            const catalogListsSubmenu = document.querySelectorAll(submenuClass);\n\n            catalogListsSubmenu.forEach(list => {\n\n                if (list.dataset.category === category) {\n                    list.classList.toggle('show', show);\n                } else {\n                    list.classList.remove('show');\n                }\n\n            });\n        };\n\n        const removeHoverClass = (list) => {\n            const listItems = list.querySelectorAll('.menu-list__item');\n\n            if (listItems.length > 0) {\n                listItems.forEach(item => item.classList.remove('hover'));\n            }\n        }\n\n\n        catalogLists.forEach(list => {\n            const catalogItems = list.querySelectorAll('.menu-list__item');\n\n            if (catalogItems.length > 0 && !list.classList.contains('submenu-2')) {\n\n                catalogItems.forEach(item => {\n\n                    item.addEventListener('mouseenter', (event) => {\n                        const {submenuClass, category} = getParentListAndCategory(event.target);\n                        removeHoverClass(list);\n                        item.classList.add('hover');\n\n                        toggleSubMenu({\n                            submenuClass,\n                            category,\n                            show: true,\n                            listItem: item\n                        });\n                    });\n\n                    // item.addEventListener('mouseleave', (event) => {\n                    //     const target = event.target;\n                    //     const { submenuClass, category } = getParentListAndCategory(target);\n                    //     // Проверяем, находится ли курсор над подменю\n                    //     const isOverSubmenu = target.matches(submenuClass) ? target : target.closest(submenuClass);\n                    //\n                    //     console.log('isOverSubmenu', isOverSubmenu);\n                    //     if (!isOverSubmenu) {\n                    //         toggleSubMenu({\n                    //             submenuClass,\n                    //             category,\n                    //             show: false,\n                    //             listItem: item\n                    //         });\n                    //     }\n                    // });\n\n                });\n\n            }\n\n        });\n    }\n\n    clickOutside({\n        el: '.header__catalog-menu',\n        btn: '.header__catalog-open',\n        className: 'open',\n        removeBtnClassName: true\n    })\n}\n\n\r\n    // плавная прокуртка\r\n    // Функция для плавной прокрутки к якорю\r\nfunction smoothScroll(e) {\r\n    e.preventDefault(); // Отменяем стандартное поведение ссылки\r\n    // Получаем ID якоря из атрибута data-href или href\r\n    const targetId = this.getAttribute('data-href') || this.getAttribute('href');\r\n\r\n    if (targetId === '#') {\r\n        console.error('В ссылке используется заглушка')\r\n        return;\r\n    }\r\n    // Находим элемент с нужным ID\r\n    const targetElement = document.querySelector(targetId);\r\n    const duration = 1000; // Длительность анимации прокрутки (в миллисекундах)\r\n    if (targetElement) { // Проверяем, найден ли элемент с нужным ID\r\n        const targetOffsetTop = targetElement.offsetTop; // Получаем вертикальное смещение элемента относительно верхнего края страницы\r\n        // Прокручиваем страницу до элемента с плавной анимацией\r\n        window.scrollTo({\r\n            top: targetOffsetTop,\r\n            behavior: 'smooth' // Опция для плавной прокрутки\r\n        });\r\n    }\r\n}\r\n\r\n// Получаем все ссылки, которые начинаются с \"#\" или имеют атрибут data-href, начинающийся с \"#\"\r\nconst links = document.querySelectorAll('a[href^=\"#\"],*[data-href^=\"#\"]');\r\n// Перебираем все найденные ссылки и назначаем им обработчик события клика для плавной прокрутки\r\nlinks.forEach(link => {\r\n    link.addEventListener('click', smoothScroll);\r\n});\r\n\r\n\r\n    // модальные окна\r\n    document.addEventListener('click', function (e) {\r\n    const target = e.target;\r\n    const isOverlay = target.classList.contains('modal');\r\n    const isCloseButton = target.classList.contains('modal__close') || target.closest('.modal__close');\r\n    const isOpenButton = target.dataset.modal;\r\n    let modal;\r\n\r\n    if (isOverlay) {\r\n        modal = target;\r\n    }\r\n\r\n    if (isCloseButton) {\r\n        modal = target.closest('.modal');\r\n    }\r\n\r\n    if (modal) {\r\n        // modal.querySelector('.modal__content').classList.remove('animated');\r\n        fadeOut(modal, 215);\r\n        document.body.classList.remove('no-scroll');\r\n    }\r\n\r\n    if (isOpenButton) {\r\n        const modalId = target.dataset.modal;\r\n        const autoSubmit = !!parseInt(target.dataset.autoSubmit) || false;\r\n\r\n        if (modalId) {\r\n            const modal = document.getElementById(modalId);\r\n            const form = modal.querySelector('form');\r\n            const selects = modal.querySelectorAll('.custom-select');\r\n\r\n            fadeIn(modal, 215)\r\n            document.body.classList.add('no-scroll');\r\n\r\n            if (selects.length > 0) {\r\n                selects.forEach(select => {\r\n                    new CustomSelect('reinit', {\r\n                        selectElement: select\r\n                    })\r\n                })\r\n            }\r\n\r\n            if (form) {\r\n                new HandlerForm({form, autoSubmit});\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\n\r\n    // Найти элемент с классом 'header__hamburger'\r\nconst hamburger = header.querySelector('.header__hamburger');\r\nconst hamburgerClose = header.querySelector('.header__close');\r\nconst hamburgerWrap = header.querySelector('.hamburger-wrap');\r\n\r\n// if (hamburger)\r\nconst closeHamburger = () => {\r\n    if (!hamburger) {\r\n        console.error('Элемент hamburger отсутствует!')\r\n        return;\r\n    }\r\n\r\n    hamburger.classList.remove('open');\r\n    hamburgerWrap.classList.remove('slideInRight');\r\n    hamburgerWrap.classList.add('slideOutRight');\r\n    document.body.classList.remove('no-scroll');\r\n    setTimeout(() => {\r\n        hamburgerWrap.classList.add('menu-hidden');\r\n    }, 1000);\r\n}\r\n// Проверить, существует ли элемент 'header__hamburger'\r\nif (hamburger) {\r\n    // Добавить обработчик события 'click' к элементу 'header__hamburger'\r\n    hamburger.addEventListener('click', event => {\r\n        // Предотвратить стандартное поведение события (например, переход по ссылке)\r\n        event.preventDefault();\r\n\r\n        // Проверить, содержит ли текущий элемент ('hamburger') класс 'open'\r\n        if (hamburger.classList.contains('open')) {\r\n            // Если содержит, удалить класс 'open' у элемента 'hamburger'\r\n            closeHamburger();\r\n        } else {\r\n            // Если класс 'open' отсутствует у элемента 'hamburger'\r\n            // Добавить класс 'open' к элементу 'hamburger'\r\n            hamburger.classList.add('open');\r\n            hamburger.classList.remove('close');\r\n            // Добавить класс 'no-scroll' к элементу 'body', чтобы предотвратить прокрутку страницы\r\n            document.body.classList.add('no-scroll');\r\n\r\n            // Удалить класс 'slideInLeft' у элемента 'hamburgerWrap' и добавить класс 'slideOutLeft'\r\n            // Это переключит анимацию меню с 'slide in' (заезд) на 'slide out' (выезд)\r\n            hamburgerWrap.classList.remove('slideOutRight');\r\n            hamburgerWrap.classList.add('slideInRight');\r\n            hamburgerWrap.classList.remove('menu-hidden');\r\n        }\r\n    });\r\n}\r\n\r\nif (hamburgerClose) {\r\n    hamburgerClose.addEventListener('click', (event) => {\r\n       event.preventDefault();\r\n        closeHamburger();\r\n    });\r\n}\r\n\r\ndocument.addEventListener('click', function (e) {\r\n    const target = e.target;\r\n    const isHamburgerWrap = target.classList.contains('header__hamburger') || target.closest('.header__hamburger');\r\n\r\n    if (!isHamburgerWrap) {\r\n        console.error('Элемент hamburger отсутствует!')\r\n        return;\r\n    }\r\n    const isCloseButton = target.classList.contains('header__close');\r\n\r\n    if (!isCloseButton) {\r\n        console.error('Элемент hamburger отсутствует!')\r\n        return;\r\n    }\r\n    // const isCloseButton = target.classList.contains('header__close') || target.closest('.header__close');\r\n    const isHamburger = target.classList.contains('header__hamburger') || target.closest('.header__hamburger');\r\n\r\n    if (!isHamburger) {\r\n        console.error('Элемент hamburger отсутствует!')\r\n        return;\r\n    }\r\n\r\n    const isOpen = hamburgerWrap.classList.contains('slideInRight');\r\n\r\n    if (!isHamburger) {\r\n        if (isHamburgerWrap || isCloseButton || isOpen) {\r\n            closeHamburger();\r\n        }\r\n    }\r\n});\r\n\r\n\r\n        /**\r\n         * инициализация аккордеона\r\n         */\r\n\r\n        const accordions = document.querySelectorAll('.accordion');\r\n\r\n        if (accordions.length > 0) {\r\n            accordions.forEach(accordion => {\r\n                const myAccordion = new Accordion(accordion, false);\r\n            })\r\n        }\r\n\r\n    /**\r\n     * инициализация масок\r\n     */\r\n\r\n// $('.input-email').inputmask({\r\n//     mask: '*{1,20}[.*{1,20}][.*{1,20}][.*{1,20}]@*{1,20}[.*{2,6}][.*{1,2}]',\r\n//     greedy: false,\r\n//     onBeforePaste: function (pastedValue, opts) {\r\n//         pastedValue = pastedValue.toLowerCase();\r\n//         return pastedValue.replace('mailto:', '');\r\n//     },\r\n//     definitions: {\r\n//         '*': {\r\n//             validator: \"[0-9A-Za-z!#$%&'*+/=?^_`{|}~\\-]\",\r\n//             casing: 'lower'\r\n//         }\r\n//     }\r\n// });\r\n\r\nconst inputsPhone = document.querySelectorAll('.input-phone');\r\nconst inputsEmail = document.querySelectorAll('.input-email');\r\n\r\nif (inputsPhone.length > 0) {\r\n\r\n    inputsPhone.forEach(function (input) {\r\n        let phoneMask = IMask(input, {\r\n            mask: '+7 (000) 000-00-00'\r\n        });\r\n    });\r\n}\r\n\r\nif (inputsEmail.length > 0) {\r\n\r\n    inputsEmail.forEach(function (input) {\r\n        var emailMask = IMask(input, {\r\n            mask: /^\\S*@?\\S*$/\r\n        });\r\n    });\r\n\r\n\r\n}\r\n\r\n\r\n    /**\r\n     * инициализация карты\r\n     */\r\n/**\n * Табы на главнйо странце в секции Geography\n */\n\nconst geographyTabs = document.querySelectorAll('.geography__tabs .geography_tab');\n\nif (geographyTabs) {\n    const geographyTabsContent = document.querySelectorAll('.geography__tabs-content .geography__tab-content');\n\n    geographyTabs.forEach(tab => {\n        tab.addEventListener('click', (e) => {\n            e.preventDefault();\n            const target = e.target;\n            const currentTab = target.classList === 'geography_tab' ? target : target.closest('.geography_tab');\n            const dataTab = currentTab.dataset.tab;\n\n            if (geographyTabsContent) {\n                geographyTabsContent.forEach(contentTab => {\n                    const dataContentTab = contentTab.dataset.tab;\n                    contentTab.style.display = dataContentTab === dataTab ? 'block' : 'none';\n                });\n            }\n\n            geographyTabs.forEach(tab => {\n                tab.classList.remove('active');\n            });\n            currentTab.classList.add('active');\n        });\n    });\n}\n\r\n\r\n\r\n// Получаем ссылки с классами '.footer__policy-link' и '.footer__agreement-link'\r\n    const policyLinks = document.querySelectorAll('.footer__links');\r\n\r\n    /**\r\n     * Функция обработчика клика по политикам в подвале\r\n     * @param e\r\n     */\r\n    function handleClick(e) {\r\n        e.preventDefault(); // Отменяем стандартное поведение ссылки\r\n        let href = this.getAttribute('href'); // Получаем значение атрибута 'href' ссылки\r\n        window.location.href = href.replace('#', ''); // Удаляем символ '#' из значения 'href' и переходим по новому адресу\r\n    }\r\n\r\n    if (policyLinks.length > 0) {\r\n// Назначаем обработчик клика на каждую найденную ссылку\r\n        policyLinks.forEach(link => {\r\n            link.addEventListener('click', handleClick);\r\n        });\r\n    }\r\n\r\n    const customSelects = document.querySelectorAll('.custom-select');\r\n\r\n    if (customSelects.length > 0) {\r\n        customSelects.forEach(select => {\r\n            new CustomSelect('init', {\r\n                selectElement: select\r\n            })\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Инит формы валидации обратной связи\r\n     */\r\n\r\n    const feedbackFormOnPage = document.getElementById('feedback_form_on_page');\r\n\r\n    if (feedbackFormOnPage) {\r\n        new HandlerForm({\r\n            form: feedbackFormOnPage,\r\n            autoSubmit: true\r\n        });\r\n    }\r\n\r\n/**\r\n * Инициализирует проверку элементов для Swiper-слайдера и добавляет необходимые классы.\r\n * @function sliderInitCheck\r\n * @param {Object} config - Объект конфигурации функции.\r\n * @param {HTMLElement} config.sliderWrapElement - Внешний контейнер слайдера.\r\n * @param {string} config.sliderClassName - Селектор класса основного контейнера слайдов.\r\n * @param {string} config.slideClassName - Селектор класса каждого слайда.\r\n * @param {boolean} [config.navButtons=true] - Флаг отображения навигационных кнопок.\r\n * @param {boolean} [config.showBullets=true] - Флаг отображения буллетов для пагинации.\r\n * @returns {Object|null} - Возвращает объект с элементами навигации и буллетов или null, если элементы не найдены.\r\n */\r\nfunction sliderInitCheck({\r\n                             sliderWrapElement,\r\n                             sliderClassName,\r\n                             slideClassName,\r\n                             navButtons = true,\r\n                             showBullets = true\r\n                         }) {\r\n    // Проверка на наличие внешнего контейнера слайдера\r\n    if (!sliderWrapElement) {\r\n        return;\r\n    }\r\n\r\n    const parentSection = sliderWrapElement.closest('section') ? sliderWrapElement.closest('section') : sliderWrapElement;\r\n\r\n    // Находим внутренний контейнер слайдов\r\n    const slider = sliderWrapElement.querySelector(sliderClassName);\r\n    if (!slider) {\r\n        return;\r\n    }\r\n\r\n    // Находим все элементы слайда внутри контейнера\r\n    const slides = slider.querySelectorAll(slideClassName);\r\n    if (slides.length <= 0) {\r\n        return;\r\n    }\r\n\r\n    // Определяем элементы навигационных кнопок, если они включены\r\n    const nextButton = navButtons ? parentSection.querySelector('.btn_next') : null;\r\n    const prevButton = navButtons ? parentSection.querySelector('.btn_prev') : null;\r\n    // console.log({sliderWrapElement, nextButton, prevButton})\r\n    // Определяем элемент для пагинации, если она включена\r\n    const bullets = showBullets ? parentSection.querySelector('.slider-bullets') : null;\r\n\r\n    // Проверка наличия всех необходимых элементов\r\n    if (!slider ||\r\n        (navButtons && (!nextButton || !prevButton)) ||\r\n        (showBullets && !bullets)) {\r\n        console.error('Не найдены необходимые элементы для Swiper в контейнере:', sliderWrapElement);\r\n        return;\r\n    }\r\n\r\n    // Добавляем необходимые классы для работы с Swiper\r\n    sliderWrapElement.classList.add('swiper');\r\n    slider.classList.add('swiper-wrapper');\r\n\r\n    // Добавляем класс 'swiper-slide' каждому элементу слайда\r\n    slides.forEach(slide => slide.classList.add('swiper-slide'));\r\n\r\n    // Возвращаем элементы навигации и пагинации для использования в Swiper\r\n    return {nextButton, prevButton, bullets};\r\n}\r\n\r\nconst setEqualHeight = (swiper) => {\r\n    let maxHeight = 0;\r\n    swiper.slides.forEach(slide => {\r\n        maxHeight = Math.max(maxHeight, slide.offsetHeight);\r\n    });\r\n    swiper.slides.forEach(slide => {\r\n        slide.style.height = `${maxHeight}px`;\r\n    });\r\n}\r\n\r\n/**\r\n * Инициализирует основной слайдер на главной странице.\r\n * @function mainHeroSlider\r\n * @param {HTMLElement} sliderWrap - Внешний контейнер слайдера на главной странице.\r\n */\r\nfunction mainHeroSlider(sliderWrap) {\r\n    // Инициализируем проверку и получаем необходимые элементы\r\n    const result = sliderInitCheck({\r\n        sliderWrapElement: sliderWrap,\r\n        sliderClassName: '.main-hero__slider',\r\n        slideClassName: '.main-hero__slider-item',\r\n    });\r\n\r\n    // Проверяем результат на наличие необходимых элементов для инициализации Swiper\r\n    if (!result) {\r\n        console.error('Ошибка инициализации слайдера: не удалось найти все необходимые элементы.');\r\n        return;\r\n    }\r\n\r\n    const {nextButton, prevButton, bullets} = result;\r\n\r\n    // Инициализация Swiper с конфигурацией\r\n    const swiper = new Swiper(sliderWrap, {\r\n        speed: 300,               // Скорость анимации перехода между слайдами\r\n        slidesPerView: 1,         // Отображать по одному слайду за раз\r\n        loop: false,              // Отключение бесконечного зацикливания слайдов\r\n        grabCursor: false,         // Включение курсора \"перетаскивания\" при наведении\r\n        pagination: {\r\n            el: bullets,          // Элемент для пагинации\r\n            type: 'bullets',      // Тип пагинации (буллеты)\r\n            clickable: true\r\n        },\r\n        navigation: {\r\n            nextEl: nextButton,   // Элемент кнопки \"вперед\"\r\n            prevEl: prevButton,   // Элемент кнопки \"назад\"\r\n        },\r\n    });\r\n}\r\n\r\n// Поиск основного слайдера на странице и его инициализация\r\nconst mainSlider = document.querySelector('.main-hero__slider-wrap');\r\nmainSlider && mainHeroSlider(mainSlider);\r\n\r\nfunction essentialSliderInit(sliderWrap) {\r\n    // Инициализируем проверку и получаем необходимые элементы\r\n    const result = sliderInitCheck({\r\n        sliderWrapElement: sliderWrap,\r\n        sliderClassName: '.essential__list',\r\n        slideClassName: '.list-item',\r\n        navButtons: false,\r\n        showBullets: false\r\n    });\r\n\r\n    // Проверяем результат на наличие необходимых элементов для инициализации Swiper\r\n    if (!result) {\r\n        console.error('Ошибка инициализации слайдера: не удалось найти все необходимые элементы.');\r\n        return;\r\n    }\r\n\r\n    const swiper = new Swiper(sliderWrap, {\r\n        slidesPerView: 'auto',\r\n        spaceBetween: 52,\r\n        freeMode: {\r\n            enabled: true,\r\n            momentum: true,\r\n            momentumRatio: 0.5, // Контроль плавности замедления\r\n        },\r\n        grabCursor: true,\r\n        // mousewheel: true,\r\n    });\r\n}\r\n\r\nconst essentialSlider = document.querySelector('.essential__list-wrap');\r\nessentialSlider && essentialSliderInit(essentialSlider);\r\n\r\nfunction productsSliderInit(sliderWrap) {\r\n    // Инициализируем проверку и получаем необходимые элементы\r\n    const result = sliderInitCheck({\r\n        sliderWrapElement: sliderWrap,\r\n        sliderClassName: '.products-list',\r\n        slideClassName: '.product-item',\r\n        showBullets: false\r\n    });\r\n\r\n    // Проверяем результат на наличие необходимых элементов для инициализации Swiper\r\n    if (!result) {\r\n        console.error('Ошибка инициализации слайдера: не удалось найти все необходимые элементы.');\r\n        return;\r\n    }\r\n\r\n    const {nextButton, prevButton} = result;\r\n\r\n    // Общие настройки для всех разрешений\r\n    const commonOptions = {\r\n        speed: 300,  // Скорость анимации слайда\r\n        slidesPerView: 'auto',\r\n        spaceBetween: 40,\r\n        loop: false,  // Отключаем зацикливание слайдов\r\n        // grabCursor: true,  // Включаем курсор \"перетаскивания\" при наведении\r\n        navigation: {\r\n            nextEl: nextButton,  // Элемент для кнопки \"вперед\"\r\n            prevEl: prevButton,  // Элемент для кнопки \"назад\"\r\n        },\r\n        on: {\r\n            init: function () {\r\n                setEqualHeight(this)\r\n            },\r\n            resize: function () {\r\n                setEqualHeight(this)\r\n            }\r\n        }\r\n    };\r\n\r\n    const swiper = new Swiper(sliderWrap, commonOptions);\r\n}\r\n\r\nconst productsSliderSection = document.querySelectorAll('.products-slider');\r\n\r\nif (productsSliderSection.length > 0) {\r\n\r\n    productsSliderSection.forEach(section => {\r\n        const sliderWrap = section.querySelector('.products-wrap');\r\n        sliderWrap && productsSliderInit(sliderWrap);\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Функция для инициализации Swiper с группировкой слайдов по заданному размеру\r\n * @param {HTMLElement} sliderWrap - Контейнер, в котором находится слайдер. Обычно это элемент с классом '.reviews__slider-wrap'.\r\n * @param {number} groupSize - Количество слайдов, которые должны быть сгруппированы вместе в одном контейнере. Например, 4 для группировки по 4 слайда.\r\n */\r\nfunction reviewsSlider(sliderWrap, groupSize) {\r\n    if (!sliderWrap) {\r\n        return;\r\n    }\r\n    // Находим внутренние элементы внутри обертки слайдера\r\n    const slider = sliderWrap.querySelector('.reviews__slider');\r\n    if (!slider) {\r\n        return;\r\n    }\r\n    const slides = slider.querySelectorAll('.review');\r\n    if (slides.length < 0) {\r\n        return;\r\n    }\r\n    const nextButton = sliderWrap.querySelector('.btn_next');\r\n    const prevButton = sliderWrap.querySelector('.btn_prev');\r\n    const pages = sliderWrap.querySelector('.slider-nav__pages');\r\n\r\n    // Проверка на существование всех необходимых элементов\r\n    if (!slider || !nextButton || !prevButton || !pages) {\r\n        console.error('Не найдены необходимые элементы для Swiper в контейнере:', sliderWrap);\r\n        return;\r\n    }\r\n\r\n    // Добавляем нужные классы для Swiper\r\n    sliderWrap.classList.add('swiper');\r\n    slider.classList.add('swiper-wrapper');\r\n\r\n    // Проверка на мобильную или десктоп версию\r\n    if (mobile < clientWidth) {\r\n        let groupedSlides = [];\r\n        slides.forEach((slide, index) => {\r\n            // Группируем слайды по 'groupSize' (например, по 4 слайда)\r\n            if (index % groupSize === 0) {\r\n                const group = document.createElement('div');\r\n                group.classList.add('swiper-slide', 'slider-item');\r\n                slider.appendChild(group);\r\n                groupedSlides.push(group);\r\n            }\r\n            // Добавляем слайды в текущую группу\r\n            groupedSlides[groupedSlides.length - 1].appendChild(slide);\r\n        });\r\n    } else {\r\n        // Для десктопа добавляем класс 'swiper-slide' к каждому слайду\r\n        slides.forEach(slide => slide.classList.add('swiper-slide'));\r\n    }\r\n\r\n    // Инициализация Swiper\r\n    const swiper = new Swiper(sliderWrap, {\r\n        speed: 300,  // Скорость анимации слайда\r\n        slidesPerView: 1,  // Показываем по одному слайду за раз\r\n        loop: false,  // Отключаем зацикливание слайдов\r\n        grabCursor: true,  // Включаем курсор \"перетаскивания\" при наведении\r\n        pagination: {\r\n            el: pages,  // Элемент для пагинации\r\n            type: 'fraction',  // Тип пагинации (фракция, например, \"1/5\")\r\n        },\r\n        navigation: {\r\n            nextEl: nextButton,  // Элемент для кнопки \"вперед\"\r\n            prevEl: prevButton,  // Элемент для кнопки \"назад\"\r\n        },\r\n    });\r\n\r\n    // Обработчик события изменения слайда\r\n    swiper.on('slideChange', function () {\r\n        // Для каждого слайда в текущем слайдере\r\n        slides.forEach(slide => {\r\n            // Проверяем, имеет ли слайд класс 'show'\r\n            if (slide.classList.contains('show')) {\r\n                // Находим кнопку \"Подробнее\" внутри текущего слайда\r\n                const btnMore = slide.querySelector('.review__btn-more');\r\n                // Удаляем класс 'show' у слайда, чтобы скрыть его\r\n                slide.classList.remove('show');\r\n                // Меняем текст кнопки на 'Развернуть отзыв', чтобы пользователь знал, что можно развернуть отзыв\r\n                btnMore.textContent = 'Развернуть отзыв';\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nfunction webinarsHeroSlider(sliderWrap) {\r\n    if (!sliderWrap) {\r\n        return;\r\n    }\r\n    // Находим внутренние элементы внутри обертки слайдера\r\n    const slider = sliderWrap.querySelector('.webinars-slider');\r\n    if (!slider) {\r\n        return;\r\n    }\r\n    const slides = slider.querySelectorAll('.slider-item');\r\n    if (slides.length < 0) {\r\n        return;\r\n    }\r\n    const nextButton = sliderWrap.querySelector('.btn_next');\r\n    const prevButton = sliderWrap.querySelector('.btn_prev');\r\n\r\n    // Добавляем нужные классы для Swiper\r\n    sliderWrap.classList.add('swiper');\r\n    slider.classList.add('swiper-wrapper');\r\n    slides.forEach(slide => slide.classList.add('swiper-slide'));\r\n\r\n    // Общие настройки для всех разрешений\r\n    const commonOptions = {\r\n        speed: 300,  // Скорость анимации слайда\r\n        slidesPerView: 4,\r\n        loop: false,  // Отключаем зацикливание слайдов\r\n        grabCursor: true,  // Включаем курсор \"перетаскивания\" при наведении\r\n        autoHeight: true,  // Автоматическая настройка высоты\r\n        navigation: {\r\n            nextEl: nextButton,  // Элемент для кнопки \"вперед\"\r\n            prevEl: prevButton,  // Элемент для кнопки \"назад\"\r\n        },\r\n    };\r\n\r\n    // Инициализация Swiper\r\n    const swiper = new Swiper(sliderWrap, {\r\n        ...commonOptions,  // Используем общие опции\r\n        // Responsive breakpoints\r\n        breakpoints: {\r\n            320: {\r\n                slidesPerView: 'auto',  // Показываем по одному слайду за раз\r\n                spaceBetween: 20,  // Отступ между слайдами\r\n                navigation: false,  // Отключаем навигацию\r\n            },\r\n            576: {\r\n                slidesPerView: 2,  // Показываем по 2 слайда за раз\r\n                spaceBetween: 20,  // Отступ между слайдами\r\n\r\n            },\r\n            809: {\r\n                slidesPerView: 2,  // Показываем по 2 слайда за раз\r\n                spaceBetween: 25,  // Отступ между слайдами для больших экранов\r\n            },\r\n        }\r\n    });\r\n}\r\n\r\nfunction coursesHeroSlider(sliderWrap) {\r\n    if (!sliderWrap) {\r\n        return;\r\n    }\r\n    // Находим внутренние элементы внутри обертки слайдера\r\n    const slider = sliderWrap.querySelector('.courses-slider');\r\n    if (!slider) {\r\n        return;\r\n    }\r\n    const slides = slider.querySelectorAll('.slider-item');\r\n    if (!slider) {\r\n        return;\r\n    }\r\n    const nextButton = sliderWrap.querySelector('.btn_next');\r\n    const prevButton = sliderWrap.querySelector('.btn_prev');\r\n\r\n    // Добавляем нужные классы для Swiper\r\n    sliderWrap.classList.add('swiper');\r\n    slider.classList.add('swiper-wrapper');\r\n    slides.forEach(slide => slide.classList.add('swiper-slide'));\r\n\r\n    // Общие настройки для всех разрешений\r\n    const commonOptions = {\r\n        speed: 300,  // Скорость анимации слайда\r\n        loop: false,  // Отключаем зацикливание слайдов\r\n        grabCursor: true,  // Включаем курсор \"перетаскивания\" при наведении\r\n        autoHeight: true,  // Автоматическая настройка высоты\r\n        navigation: {\r\n            nextEl: nextButton,  // Элемент для кнопки \"вперед\"\r\n            prevEl: prevButton,  // Элемент для кнопки \"назад\"\r\n        },\r\n    };\r\n\r\n    // Инициализация Swiper\r\n    const swiper = new Swiper(sliderWrap, {\r\n        ...commonOptions,  // Используем общие опции\r\n        // Responsive breakpoints\r\n        breakpoints: {\r\n            320: {\r\n                slidesPerView: 'auto',  // Показываем по одному слайду за раз\r\n                spaceBetween: 20,  // Отступ между слайдами\r\n                navigation: false,  // Отключаем навигацию\r\n            },\r\n            576: {\r\n                slidesPerView: 2,  // Показываем по 2 слайда за раз\r\n                spaceBetween: 20,  // Отступ между слайдами\r\n            },\r\n            809: {\r\n                slidesPerView: 2,  // Показываем по 2 слайда за раз\r\n                spaceBetween: 25,  // Отступ между слайдами для больших экранов\r\n            },\r\n        }\r\n    });\r\n}\r\n\r\nfunction otherWebinarsSlider(sliderWrap) {\r\n    if (!sliderWrap) {\r\n        return;\r\n    }\r\n    // Находим внутренние элементы внутри обертки слайдера\r\n    const slider = sliderWrap.querySelector('.webinars-others__slider');\r\n    if (!slider) {\r\n        return;\r\n    }\r\n    const slides = slider.querySelectorAll('.slider-item');\r\n    if (slides.length < 0) {\r\n        return;\r\n    }\r\n    const nextButton = sliderWrap.querySelector('.btn_next');\r\n    const prevButton = sliderWrap.querySelector('.btn_prev');\r\n\r\n    // Добавляем нужные классы для Swiper\r\n    sliderWrap.classList.add('swiper');\r\n    slider.classList.add('swiper-wrapper');\r\n    slides.forEach(slide => slide.classList.add('swiper-slide'));\r\n\r\n    // Общие настройки для всех разрешений\r\n    const commonOptions = {\r\n        speed: 300,  // Скорость анимации слайда\r\n        loop: false,  // Отключаем зацикливание слайдов\r\n        autoHeight: true,  // Автоматическая настройка высоты\r\n        grabCursor: true,  // Включаем курсор \"перетаскивания\" при наведении\r\n        navigation: {\r\n            nextEl: nextButton,  // Элемент для кнопки \"вперед\"\r\n            prevEl: prevButton,  // Элемент для кнопки \"назад\"\r\n        },\r\n    };\r\n\r\n    // Инициализация Swiper\r\n    const swiper = new Swiper(sliderWrap, {\r\n        ...commonOptions,  // Используем общие опции\r\n        // Responsive breakpoints\r\n        breakpoints: {\r\n            320: {\r\n                slidesPerView: 'auto',  // Показываем по одному слайду за раз\r\n                spaceBetween: 20,  // Отступ между слайдами\r\n            },\r\n            809: {\r\n                slidesPerView: 2,  // Показываем по 2 слайда за раз\r\n                spaceBetween: 40,  // Отступ между слайдами для больших экранов\r\n            },\r\n        }\r\n    });\r\n}\r\n\r\n\r\n// Находим все элементы с классом '.reviews__slider-wrap'\nconst reviewsSliders = document.querySelectorAll('.reviews__slider-wrap');\n\n// Проверяем, есть ли элементы с указанным классом\nif (reviewsSliders.length > 0) {\n    // Для каждого найденного слайдера инициализируем Swiper\n    reviewsSliders.forEach(slider => {\n        // Вызываем функцию инициализации Swiper с указанным размером группировки слайдов\n        reviewsSlider(slider, 4);\n\n        // Находим все элементы с классом '.review' внутри текущего слайдера\n        const reviews = slider.querySelectorAll('.review');\n\n        // Проверяем, есть ли элементы с классом '.review'\n        if (reviews.length > 0) {\n            // Для каждого найденного элемента с классом '.review'\n            reviews.forEach(review => {\n                // Находим кнопку \"Подробнее\" внутри текущего отзыва\n                const btnMore = review.querySelector('.review__btn-more');\n\n                // Проверяем, существует ли кнопка \"Подробнее\"\n                if (btnMore) {\n                    // Добавляем обработчик события 'click' для кнопки \"Подробнее\"\n                    btnMore.addEventListener('click', event => {\n                        // Предотвращаем действие по умолчанию для события клика\n                        event.preventDefault();\n\n                        // Переключаем класс 'show' для текущего отзыва, чтобы показать или скрыть его\n                        review.classList.toggle('show');\n\n                        // Меняем текст кнопки в зависимости от состояния отзыва\n                        btnMore.textContent = review.classList.contains('show') ? 'Свернуть отзыв' : 'Развернуть отзыв';\n                    });\n                }\n            });\n        }\n    });\n}\n\nconst reviewFile = document.getElementById('custom_review_file');\n\nif (reviewFile) {\n    let customFile;\n    const reviewFileParent = reviewFile.closest('.review-photo');\n    const outputContainer = reviewFileParent.querySelector('.review-photo__output');\n    const outputHtml = outputContainer.innerHTML;\n\n    reviewFile.addEventListener('change', (e) => {\n        let remove, img, plug;\n\n        const image = reviewFileParent.querySelector('.review-photo__output-image');\n        plug = document.querySelector('.review-photo__output-plug');\n\n        if (image) {\n            image.remove();\n            reviewFileParent.querySelector('.review-photo__output-remove').remove();\n            plug.style.display = 'block';\n        }\n\n        customFile = e.target.files[0];\n\n        remove = document.createElement('span');\n        remove.classList.add('review-photo__output-remove');\n\n        img = document.createElement('img');\n        img.classList.add('review-photo__output-image');\n        img.file = customFile;\n\n        // outputContainer.innerHTML = '';\n\n        outputContainer.append(remove);\n        outputContainer.append(img);\n        plug.style.display = 'none';\n\n        var reader = new FileReader();\n        reader.onload = (function (aImg) {\n            return function (e) {\n                aImg.src = e.target.result;\n            };\n        })(img);\n        reader.readAsDataURL(customFile);\n        if (customFile) {\n            reviewFileParent.closest('.modal').querySelector('.checkbox-permission_publish input').classList.add('required');\n        } else {\n            reviewFileParent.closest('.modal').querySelector('.checkbox-permission_publish input').classList.remove('required');\n        }\n\n        remove.addEventListener('click', function (e) {\n            e.preventDefault();\n\n            outputContainer.innerHTML = outputHtml;\n            reviewFile.value = '';\n            reviewFileParent.closest('.modal').querySelector('.checkbox-permission_publish input').classList.remove('required');\n        });\n    });\n\n}\n\nconst reviewsButtons = document.querySelectorAll('button[data-modal=\"modal_review\"]');\n\nif (reviewsButtons.length > 0) {\n\n    reviewsButtons.forEach(button => {\n\n        button.addEventListener('click', (event) => {\n            const parent = document.querySelector('.review-photo');\n            const image = parent.querySelector('.review-photo__output-image');\n            const plug = document.querySelector('.review-photo__output-plug');\n\n            if (image) {\n                image.remove();\n                parent.querySelector('.review-photo__output-remove').remove();\n                plug.style.display = 'block';\n            }\n        });\n\n    });\n\n}\n\n// function addReviewRequest() {\n//     /**\n//      * Функция вызывается перед отправкой запроса и добавляет класс 'loader' к элементу body для отображения индикатора загрузки.\n//      */\n//     const beforeSend = () => document.body.classList.add('loader');\n//\n//     const success = (response, form) => {\n//         console.log(response);\n//         // console.log(form);\n//     }\n//\n//     /**\n//      * Функция вызывается при возникновении ошибки во время запроса и обрабатывает ошибку.\n//      * @param {XMLHttpRequest} xhr - Объект XMLHttpRequest, содержащий информацию о запросе.\n//      * @param {string} exception - Строка, содержащая описание типа ошибки.\n//      */\n//     const onError = (xhr, exception) => ajaxErrors(xhr, exception);\n//\n//     /**\n//      * Функция вызывается после завершения выполнения запроса и удаляет класс 'loader' у элемента body для скрытия индикатора загрузки.\n//      */\n//     const onComplete = () => document.body.classList.remove('loader');\n//\n//     // Возвращаем объект с функциями обратного вызова\n//     return {beforeSend, success, onError, onComplete};\n// }\n\r\n/**\n * Функция для бесконечной горизонтальной прокрутки содержимого внутри оберток .running-line__wrap\n * @param {DOMHighResTimeStamp} timestamp - Время в миллисекундах, предоставленное requestAnimationFrame для анимации\n */\nfunction scrollHorizontally(timestamp) {\n    // Получаем все обертки .running-line__wrap\n    const parent = document.querySelector('.running-line');\n    if (!parent) {\n        return\n    }\n    const child = parent.firstElementChild;\n    const wrappers = document.querySelectorAll('.running-line__wrap');\n\n    // Получаем ширину одной обертки (предполагаем, что все обертки имеют одинаковую ширину)\n    const childWidth = child.offsetWidth / 2;\n\n    // Вычисляем смещение (offset), которое должно увеличиваться постоянно для эффекта бесконечной прокрутки\n    const offset = (timestamp / 10) % childWidth; // Делим timestamp на 10, чтобы скорость прокрутки была медленнее\n\n    // Прокручиваем каждую обертку по горизонтали на заданное смещение\n    wrappers.forEach((wrapper, index) => {\n        wrapper.style.transform = `translateX(-${offset}px)`;\n    });\n\n    // Повторяем анимацию, вызывая функцию снова на следующем кадре\n    requestAnimationFrame(scrollHorizontally);\n}\n\n// Начинаем бесконечную горизонтальную прокрутку при загрузке страницы\nrequestAnimationFrame(scrollHorizontally);\n\r\n/**\n *\n * @returns {*}\n */\nfunction getUtm() {\n    let utm_tags = {};\n\n    if ('save_utm_source' in localStorage && 'save_utm_medium' in localStorage && 'save_utm_campaign' in localStorage) {\n        utm_tags['utm_source'] = localStorage['save_utm_source'];\n        utm_tags['utm_medium'] = localStorage['save_utm_medium'];\n        utm_tags['utm_campaign'] = localStorage['save_utm_campaign'];\n\n        if ('save_utm_content' in localStorage) {\n            utm_tags['utm_content'] = localStorage['save_utm_content'];\n        }\n\n        if ('save_utm_term' in localStorage) {\n            utm_tags['utm_term'] = localStorage['save_utm_term'];\n        }\n\n        if ('save_utm_referrer' in localStorage) {\n            utm_tags['utm_referrer'] = localStorage['save_utm_referrer'];\n        }\n    }\n\n    return utm_tags;\n}\n\r\nfunction ajaxErrors(xhr, exception = '') {\n    // Вывод информации о запросе в консоль для отладки\n    console.log(xhr);\n\n    // Обработка различных типов ошибок\n    if (xhr.status === 0) {\n        // Ошибка при отсутствии соединения\n        console.error('Нет соединения. Проверьте сеть.');\n    } else if (xhr.status === 404) {\n        // Ошибка 404: страница не найдена\n        console.error('Запрошенная страница не найдена (404).');\n    } else if (xhr.status === 500) {\n        // Ошибка 500: внутренняя ошибка сервера\n        console.error('Внутренняя ошибка сервера (500).');\n    } else if (exception === 'parsererror') {\n        // Ошибка при синтаксическом анализе JSON\n        console.error('Не удалось выполнить запрошенный синтаксический анализ JSON. (parse failed)');\n    } else if (exception === 'timeout') {\n        // Превышен лимит времени ожидания запроса\n        console.error('Превышен лимит времени на запрос.');\n    } else if (exception === 'abort') {\n        // Запрос был прерван\n        console.error('Запрос прерван.');\n    } else {\n        // Обработка неопределенной ошибки\n        console.error('Неопределенная ошибка. ' + xhr.responseText);\n        console.error('Убрать с обработчика на бекенде все дебаги и повторить');\n    }\n}\n\r\n});\r\n"]}